<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Roulette Mapper â€“ Standalone (EU + US)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <style>
    :root{
      --bg:#0b0f14; --panel:#10161e; --panel2:#0f141b; --text:#e7eef7; --muted:#9bb0c6;
      --accent:#50e3c2; --danger:#ff6b6b; --warn:#ffc857; --line:#1e2733; --blue:#4aa3ff; --green:#1bd760;
    }
    *{box-sizing:border-box}
    html,body{height:100%; min-height:100vh}
    body{margin:0; background:var(--bg); color:var(--text); font:14px/1.45 Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;}
    header{display:flex; align-items:center; gap:12px; padding:12px 16px; border-bottom:1px solid var(--line);
      background:linear-gradient(180deg, rgba(255,255,255,.03), transparent); position:sticky; top:0; z-index:3}
    header h1{font-size:16px; margin:0; font-weight:600}
    header .tag{padding:4px 8px; border-radius:999px; background:#0e293f; color:#9bd0ff; font-weight:600}
    main{display:grid; grid-template-columns:340px 1fr; height:calc(100vh - 54px)}
    aside{background:var(--panel); border-right:1px solid var(--line); padding:12px; overflow:auto}
    #workspace{position:relative; overflow:hidden; background:var(--panel2)}
    .group{border:1px solid var(--line); border-radius:10px; padding:12px; margin-bottom:12px; background:rgba(255,255,255,0.02)}
    .group h2{margin:0 0 8px 0; font-size:13px; color:var(--muted); text-transform:uppercase; letter-spacing:.06em}
    .row{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
    button,.btn{background:#15202b; color:var(--text); border:1px solid var(--line); padding:8px 10px; border-radius:8px; cursor:pointer; font-weight:600}
    button:hover{background:#1a2633}
    button.primary{background:var(--blue); border-color:transparent; color:#031422}
    button.warn{background:var(--warn); color:#1c1405; border-color:transparent}
    button.ghost{background:transparent}
    input[type=file]{display:none}
    label.file{display:inline-flex; align-items:center; gap:8px; cursor:pointer; border:1px dashed var(--line); padding:10px 12px; border-radius:8px}
    .pill{padding:2px 6px; border-radius:6px; background:#0b2030; color:#9bd0ff; font-weight:700; font-size:12px}
    .status{display:flex; gap:8px; align-items:center; color:var(--muted)}
    .progress{height:8px; background:#0f1620; border-radius:6px; overflow:hidden; border:1px solid var(--line)}
    .progress > div{height:100%; background:var(--green); width:0%}
    #canvas{position:absolute; inset:0; width:100%; height:100%; background:#0a0f14; cursor:crosshair}
    .hint{font-size:12px; color:var(--muted)}
    .callout{padding:10px 12px; border:1px solid #193144; background:#0d1f2e; border-radius:10px}
    .sep{height:1px; background:var(--line); margin:8px 0}
    .small{font-size:12px; color:var(--muted)}
    .legend{display:grid; grid-template-columns:repeat(2, minmax(0,1fr)); gap:6px; font-size:12px; color:var(--muted)}
    .legend span{white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
    .nowrap{white-space:nowrap}
    select, input[type="checkbox"]{cursor:pointer}
  </style>
</head>
<body>
  <header>
    <h1>Roulette Mapper</h1>
    <span class="tag">Standalone</span>
    <span class="small">Clientâ€‘side â€¢ No sandbox â€¢ Works in Chrome/Safari</span>
  </header>
  <main>
    <aside>
      <div class="group">
        <h2>Read first</h2>
        <div class="callout small">
          â€¢ Use <b>practice mode</b> or a static table screenshot.<br>
          â€¢ Capture <b>full screen</b>, entire layout (inside grid, outside bets, buttons, racetrack).<br>
          â€¢ <b>Donâ€™t crop</b>. Keep the same browser zoom & window size for mapping/automation.<br>
          â€¢ Hide chat/history overlays.
        </div>
      </div>

      <div class="group">
        <h2>Screenshot</h2>
        <div class="row">
          <label class="file">
            <input id="fileInput" type="file" accept="image/*" />
            <span>ðŸ“¤ Upload Screenshot</span>
          </label>
          <button id="resetViewBtn" class="ghost">Reset View</button>
        </div>
        <div class="row">
          <button id="zoomOutBtn">Zoom âˆ’</button>
          <button id="zoomInBtn">Zoom +</button>
          <span class="hint">Viewâ€‘only zoom & pan (drag)</span>
        </div>
      </div>

      <!-- NEW: Rebase / Scaling panel -->
      <div class="group" id="rebasePanel">
        <h2>Rebase / Scaling (export)</h2>
        <div class="row">
          <label class="nowrap" for="rebaseToggle">Enable</label>
          <input id="rebaseToggle" type="checkbox" />
          <span class="hint">Export in a different coordinate system</span>
        </div>
        <div class="row">
          <label class="nowrap" for="baseWidth">Base W</label>
          <input id="baseWidth" type="number" min="1" step="1" style="width:110px" placeholder="e.g. 2560" />
          <label class="nowrap" for="baseHeight">Base H</label>
          <input id="baseHeight" type="number" min="1" step="1" style="width:110px" placeholder="e.g. 1440" />
        </div>
        <div class="row">
          <label class="nowrap" for="offsetX">Offset X</label>
          <input id="offsetX" type="number" step="1" style="width:110px" value="0" />
          <label class="nowrap" for="offsetY">Offset Y</label>
          <input id="offsetY" type="number" step="1" style="width:110px" value="0" />
        </div>
        <div class="row">
          <label class="nowrap" for="scaleX">Scale X</label>
          <input id="scaleX" type="number" step="0.0001" style="width:110px" value="1" />
          <label class="nowrap" for="scaleY">Scale Y</label>
          <input id="scaleY" type="number" step="0.0001" style="width:110px" value="1" />
        </div>
        <div class="row">
          <button id="autoScaleBtn" class="ghost">Auto-scale from base size</button>
          <span class="hint">Sets scale to Base Ã· Image (uses the uploaded imageâ€™s natural size)</span>
        </div>
        <div class="small">
          <div class="sep"></div>
          <b>Typical use:</b> Mapped a <i>cropped right-side</i> shot but script runs in <b>full-screen</b>?<br>
          â€¢ Set Base W/H to your monitor (e.g., 2560Ã—1440).<br>
          â€¢ Set Offset X/Y to the cropâ€™s topâ€‘left inside the full screen.<br>
          â€¢ If resized, click <b>Auto-scale</b> after entering Base W/H.
        </div>
      </div>

      <div class="group">
        <h2>Mapping</h2>
        <div class="row">
          <label class="nowrap" for="variantSelect">Variant</label>
          <select id="variantSelect">
            <option value="EU" selected>European (singleâ€‘zero)</option>
            <option value="US">American (doubleâ€‘zero)</option>
          </select>
          <span class="hint">Affects singles & zeroâ€‘area steps</span>
        </div>
        <div class="status">
          <span id="stepLabel" class="pill">â€”</span>
          <span id="stepHelp" class="small">Click to startâ€¦</span>
        </div>
        <div class="sep"></div>
        <div class="row">
          <button id="undoBtn">Undo</button>
          <button id="skipBtn" class="warn">Skip</button>
        </div>
        <div class="row">
          <label class="nowrap" for="depthSelect">Depth</label>
          <select id="depthSelect">
            <option value="basic" selected>Basic (â‰ˆ80â€“84)</option>
            <option value="full">Full (159+)</option>
          </select>
          <label class="nowrap" style="margin-left:8px"><input id="racetrackToggle" type="checkbox"/> Include Racetrack steps</label>
        </div>
        <div class="sep"></div>
        <div class="progress"><div id="progressBar"></div></div>
        <div class="small"><span id="progressText">0 / 0</span> mapped</div>
      </div>

      <div class="group">
        <h2>Export / Import</h2>
        <div class="row">
          <button id="exportJsonBtn" class="primary">Export JSON</button>
          <button id="openJsonBtn">Open JSON</button>
        </div>
        <div class="row">
          <button id="openOverlayBtn">Open Overlay PNG</button>
        </div>
        <div class="row">
          <label class="file">
            <input id="importJsonInput" type="file" accept="application/json" />
            <span>ðŸ“¥ Import JSON</span>
          </label>
          <button id="clearAllBtn">Clear</button>
        </div>
      </div>

      <div class="group">
        <h2>Legend</h2>
        <div class="legend">
          <span>â€¢ Singles 0â€“36 (US adds 00)</span>
          <span>â€¢ Colors R/B/G</span>
          <span>â€¢ Dozens (1st/2nd/3rd)</span>
          <span>â€¢ Columns (1/2/3)</span>
          <span>â€¢ 1â€“18 / Even / Odd / 19â€“36</span>
          <span>â€¢ Streets (12) & Sixlines (11)</span>
          <span>â€¢ Zero area: First Four (EU) / First Five (US)</span>
          <span>â€¢ Zero splits incl. 0â€“1/2/3 (+ 0â€“00, 00â€“2/3 in US)</span>
          <span>â€¢ Buttons: Spin / Result / Double</span>
          <span>â€¢ Calibration: Numbers grid bbox</span>
          <span>â€¢ Racetrack (bbox + Voisins/Tiers/Orphelins/Jeu ZÃ©ro)</span>
        </div>
      </div>

      <div class="group">
        <h2>Quality check</h2>
        <div class="small">
          Open overlay PNG and confirm:<br>
          â€¢ Points are centered â€¢ Regions hug buttons â€¢ Coverage is complete
        </div>
      </div>
    </aside>

    <section id="workspace">
      <canvas id="canvas" tabindex="0" aria-label="mapping canvas"></canvas>
    </section>
  </main>

<script>
(() => {
  // ---------- DOM ----------
  const fileInput = document.getElementById('fileInput');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const zoomInBtn = document.getElementById('zoomInBtn');
  const zoomOutBtn = document.getElementById('zoomOutBtn');
  const resetViewBtn = document.getElementById('resetViewBtn');
  const undoBtn = document.getElementById('undoBtn');
  const skipBtn = document.getElementById('skipBtn');
  const racetrackToggle = document.getElementById('racetrackToggle');
  const exportJsonBtn = document.getElementById('exportJsonBtn');
  const openJsonBtn = document.getElementById('openJsonBtn');
  const openOverlayBtn = document.getElementById('openOverlayBtn');
  const importJsonInput = document.getElementById('importJsonInput');
  const clearAllBtn = document.getElementById('clearAllBtn');
  const stepLabel = document.getElementById('stepLabel');
  const stepHelp = document.getElementById('stepHelp');
  const progressBar = document.getElementById('progressBar');
  const progressText = document.getElementById('progressText');
  const depthSelect = document.getElementById('depthSelect');
  const variantSelect = document.getElementById('variantSelect');

  // NEW: Rebase / Scaling DOM
  const rebaseToggle = document.getElementById('rebaseToggle');
  const baseWidthInput = document.getElementById('baseWidth');
  const baseHeightInput = document.getElementById('baseHeight');
  const offsetXInput = document.getElementById('offsetX');
  const offsetYInput = document.getElementById('offsetY');
  const scaleXInput = document.getElementById('scaleX');
  const scaleYInput = document.getElementById('scaleY');
  const autoScaleBtn = document.getElementById('autoScaleBtn');

  // ---------- State ----------
  let img = null;          // HTMLImageElement fallback
  let imgBitmap = null;    // ImageBitmap (fast path)
  let view = { scale: 1, tx: 0, ty: 0 };
  let isPanning = false, panStart = {x:0, y:0}, viewStart = {tx:0, ty:0};

  let steps = [];
  let stepIndex = 0;
  let data = {};
  let history = [];
  let pendingRegionFirst = null;

  const colors = { point:'#50e3c2', region:'#4aa3ff', current:'#ffa657', text:'#e7eef7', ghost:'rgba(255,255,255,0.15)' };

  // NEW: Rebase / Scaling state
  let rebase = {
    enabled: false,
    baseW: 0,
    baseH: 0,
    offX: 0,
    offY: 0,
    scaleX: 1,
    scaleY: 1,
  };

  function syncRebaseFromUI() {
    rebase.enabled = !!rebaseToggle?.checked;
    rebase.baseW  = parseInt(baseWidthInput?.value || '0', 10) || 0;
    rebase.baseH  = parseInt(baseHeightInput?.value || '0', 10) || 0;
    rebase.offX   = parseFloat(offsetXInput?.value || '0') || 0;
    rebase.offY   = parseFloat(offsetYInput?.value || '0') || 0;
    rebase.scaleX = parseFloat(scaleXInput?.value || '1') || 1;
    rebase.scaleY = parseFloat(scaleYInput?.value || '1') || 1;
  }

  function applyRebase(pt) {
    if (!rebase.enabled) return { x: Math.round(pt.x), y: Math.round(pt.y) };
    return {
      x: Math.round(pt.x * rebase.scaleX + rebase.offX),
      y: Math.round(pt.y * rebase.scaleY + rebase.offY),
    };
  }

  // Wire inputs
  [rebaseToggle, baseWidthInput, baseHeightInput, offsetXInput, offsetYInput, scaleXInput, scaleYInput]
    .forEach(el => el && el.addEventListener('input', syncRebaseFromUI));

  if (autoScaleBtn) {
    autoScaleBtn.addEventListener('click', () => {
      if (!img) { alert('Upload an image first.'); return; }
      const bw = parseInt(baseWidthInput.value || '0', 10) || 0;
      const bh = parseInt(baseHeightInput.value || '0', 10) || 0;
      if (!bw || !bh) { alert('Enter Base W/H first.'); return; }
      // Uses the imageâ€™s natural size (img.width/height), not the onâ€‘screen zoom
      scaleXInput.value = (bw / img.width).toFixed(6);
      scaleYInput.value = (bh / img.height).toFixed(6);
      syncRebaseFromUI();
    });
  }

  // ---------- Canvas sizing ----------
  function resizeCanvasToDisplaySize() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    const width = Math.max(1, Math.floor(rect.width * dpr));
    const height = Math.max(1, Math.floor(rect.height * dpr));
    if (canvas.width !== width || canvas.height !== height) { canvas.width = width; canvas.height = height; }
  }

  // ---------- Steps ----------
  function buildSteps(includeRacetrack, depth, variant) {
    const s = [];
    const isUS = variant === 'US';

    // Singles
    s.push({ key:`single_0`, label:`Number 0`, type:'point', help:'Click center of 0' });
    if (isUS) s.push({ key:`single_00`, label:`Number 00`, type:'point', help:'Click center of 00' });
    for (let n = 1; n <= 36; n++) s.push({ key:`single_${n}`, label:`Number ${n}`, type:'point', help:'Click center of the number box' });

    // Colors
    s.push({ key:'color_red',   label:'Color Red',   type:'point', help:'Click the Red box' });
    s.push({ key:'color_black', label:'Color Black', type:'point', help:'Click the Black box' });
    s.push({ key:'color_green', label:'Color Green', type:'point', help:'If no Green box, use 0 or 00' });

    // Dozens
    s.push({ key:'dozen_1', label:'1st 12', type:'point', help:'Click 1st12' });
    s.push({ key:'dozen_2', label:'2nd 12', type:'point', help:'Click 2nd12' });
    s.push({ key:'dozen_3', label:'3rd 12', type:'point', help:'Click 3rd12' });

    // Columns
    s.push({ key:'column_1', label:'Column 1', type:'point', help:'Click Column 1' });
    s.push({ key:'column_2', label:'Column 2', type:'point', help:'Click Column 2' });
    s.push({ key:'column_3', label:'Column 3', type:'point', help:'Click Column 3' });

    // Even chances
    s.push({ key:'even_low',  label:'1â€“18',  type:'point', help:'Click 1â€“18' });
    s.push({ key:'even_even', label:'Even',  type:'point', help:'Click Even' });
    s.push({ key:'even_odd',  label:'Odd',   type:'point', help:'Click Odd' });
    s.push({ key:'even_high', label:'19â€“36', type:'point', help:'Click 19â€“36' });

    // Streets (12 rows)
    for (let i=0;i<12;i++){ const start = 1 + i*3; const end = start + 2; s.push({ key:`street_${i+1}`, label:`Street ${i+1} (${start}â€“${end})`, type:'point', help:'Click the street wager spot' }); }
    // Sixlines (11)
    for (let i=0;i<11;i++){ const start = 1 + i*3; const end = start + 5; s.push({ key:`sixline_${i+1}`, label:`Sixline ${i+1} (${start}â€“${end})`, type:'point', help:'Click the sixline wager spot' }); }

    // Zero area (variant-specific)
    if (isUS) {
      s.push({ key:'first_five', label:'First Five (0â€“00â€“1â€“2â€“3)', type:'point', help:'Click First Five box' });
      s.push({ key:'split_0_00', label:'Split 0â€“00', type:'point', help:'Click between 0 and 00' });
      s.push({ key:'split_00_2', label:'Split 00â€“2', type:'point', help:'Click split 00â€“2' });
      s.push({ key:'split_00_3', label:'Split 00â€“3', type:'point', help:'Click split 00â€“3' });
      s.push({ key:'split_0_1', label:'Split 0â€“1', type:'point', help:'Click Split 0â€“1' });
      s.push({ key:'split_0_2', label:'Split 0â€“2', type:'point', help:'Click Split 0â€“2' });
      s.push({ key:'split_0_3', label:'Split 0â€“3', type:'point', help:'Click Split 0â€“3' });
    } else {
      s.push({ key:'first_four', label:'First Four (0â€“1â€“2â€“3)', type:'point', help:'Click First Four box' });
      s.push({ key:'split_0_1', label:'Split 0â€“1', type:'point', help:'Click Split 0â€“1' });
      s.push({ key:'split_0_2', label:'Split 0â€“2', type:'point', help:'Click Split 0â€“2' });
      s.push({ key:'split_0_3', label:'Split 0â€“3', type:'point', help:'Click Split 0â€“3' });
    }

    // Calibration (numbers grid bbox)
    s.push({ key:'calib_grid_bbox', label:'Calibration: Numbers grid bbox', type:'region', help:'Drag around the 1â€“36 grid area' });

    // Buttons (regions)
    s.push({ key:'btn_spin',   label:'Spin button',   type:'region', help:'Drag a box: topâ€‘left then bottomâ€‘right' });
    s.push({ key:'btn_result', label:'Result panel',  type:'region', help:'Drag a box: topâ€‘left then bottomâ€‘right' });
    s.push({ key:'btn_double', label:'Double button', type:'region', help:'Drag a box: topâ€‘left then bottomâ€‘right' });

    // Racetrack optional
    if (includeRacetrack) {
      s.push({ key:'rt_bbox', label:'Racetrack bbox', type:'region', help:'Drag a box covering the racetrack area' });
      s.push({ key:'rt_voisins',   label:'Racetrack: Voisins',   type:'point', help:'Click Voisins' });
      s.push({ key:'rt_tiers',     label:'Racetrack: Tiers',     type:'point', help:'Click Tiers' });
      s.push({ key:'rt_orphelins', label:'Racetrack: Orphelins', type:'point', help:'Click Orphelins' });
      s.push({ key:'rt_jeu_zero',  label:'Racetrack: Jeu ZÃ©ro',  type:'point', help:'Click Jeu ZÃ©ro' });
    }

    // Extra sets for FULL depth (inside-grid splits & corners)
    if (depth === 'full') {
      // Horizontal splits per row
      for (let r=0; r<12; r++) {
        const a = 3*r + 1; const b = a + 1; const c = b + 1;
        s.push({ key:`split_${a}_${b}`, label:`Split ${a}â€“${b}`, type:'point', help:'Click the split between boxes' });
        s.push({ key:`split_${b}_${c}`, label:`Split ${b}â€“${c}`, type:'point', help:'Click the split between boxes' });
      }
      // Vertical splits between rows
      for (let r=0; r<11; r++) {
        for (let c=1; c<=3; c++) {
          const n = 3*r + c; const m = n + 3;
          s.push({ key:`split_${n}_${m}`, label:`Split ${n}â€“${m}`, type:'point', help:'Click the split between boxes' });
        }
      }
      // Corners (2x2)
      for (let r=0; r<11; r++) {
        for (let c=1; c<=2; c++) {
          const tl = 3*r + c; const tr = tl + 1; const bl = tl + 3; const br = bl + 1;
          s.push({ key:`corner_${tl}_${tr}_${bl}_${br}`, label:`Corner ${tl}-${tr}-${bl}-${br}`, type:'point', help:'Click the intersection point' });
        }
      }
    }
    return s;
  }

  function resetSteps() {
    steps = buildSteps(
      racetrackToggle.checked,
      (depthSelect && depthSelect.value) || 'basic',
      (variantSelect && variantSelect.value) || 'EU'
    );
    const firstIncomplete = steps.findIndex(st => !data[st.key] || data[st.key].skipped);
    stepIndex = Math.max(0, firstIncomplete === -1 ? 0 : firstIncomplete);
    updateUI(); draw();
  }

  // ---------- Image loading ----------
  fileInput.addEventListener('change', async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    try {
      try { imgBitmap = window.createImageBitmap ? await createImageBitmap(file) : null; } catch(_) { imgBitmap = null; }
      const fr = new FileReader();
      fr.onload = () => {
        const im = new Image();
        im.onload = () => { img = im; fitView(); draw(); };
        im.onerror = () => alert('Failed to decode image. Try a different file.');
        im.src = String(fr.result);
      };
      fr.onerror = () => alert('Failed to read image file.');
      fr.readAsDataURL(file);
    } catch (err) { alert('Failed to load image: ' + (err && err.message ? err.message : err)); }
  });

  function fitView() {
    resizeCanvasToDisplaySize(); if (!img) return;
    const cw = canvas.width, ch = canvas.height;
    const sx = cw / img.width, sy = ch / img.height;
    const scale = Math.min(sx, sy) * 0.95;
    const imgW = img.width * scale, imgH = img.height * scale;
    view.scale = scale; view.tx = (cw - imgW) / 2; view.ty = (ch - imgH) / 2;
  }

  window.addEventListener('resize', () => { resizeCanvasToDisplaySize(); fitView(); draw(); });

  // ---------- Coordinate math ----------
  function canvasToImage(x, y) { return { x: (x - view.tx) / view.scale, y: (y - view.ty) / view.scale }; }
  function imageToCanvas(x, y) { return { x: x * view.scale + view.tx, y: y * view.scale + view.ty }; }
  function clampToImage(pt) { if (!img) return pt; return { x: Math.max(0, Math.min(img.width, pt.x)), y: Math.max(0, Math.min(img.height, pt.y)) }; }

  // ---------- Draw ----------
  function draw() {
    resizeCanvasToDisplaySize();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width, canvas.height);
    ctx.fillStyle = '#0a0f14'; ctx.fillRect(0,0,canvas.width, canvas.height);

    const baseImage = imgBitmap || img;
    if (baseImage) {
      ctx.setTransform(view.scale, 0, 0, view.scale, view.tx, view.ty);
      ctx.drawImage(baseImage, 0, 0);
      drawOverlay(ctx, false);
      const st = steps[stepIndex];
      if (st && st.type === 'region' && pendingRegionFirst) {
        ctx.save(); ctx.globalAlpha = 0.6; ctx.strokeStyle = colors.current; ctx.setLineDash([8,6]);
        drawCrosshair(pendingRegionFirst.x, pendingRegionFirst.y, colors.current); ctx.restore();
      }
    } else {
      ctx.setTransform(1,0,0,1,0,0);
      ctx.font = '14px ui-monospace, Menlo, Consolas, monospace';
      ctx.fillStyle = '#9bb0c6';
      ctx.fillText('Upload a screenshot to begin mapping.', 16, 24);
    }
  }

  function drawOverlay(g, final=false) {
    const circleR = 8; const sc = final ? 1 : view.scale; // keep label sizes consistent
    g.lineWidth = 2 / sc; g.font = `${12 / sc}px ui-monospace, Menlo, Consolas, monospace`; g.textBaseline = 'top';
    for (const st of steps) {
      const val = data[st.key]; if (!val || val.skipped) continue;
      if (val.type === 'point') {
        const {x, y} = val; g.fillStyle = colors.point; g.strokeStyle = 'black';
        g.beginPath(); g.arc(x, y, circleR / sc, 0, Math.PI*2); g.fill(); g.stroke();
        g.fillStyle = colors.text; g.fillText(labelShort(st.label), x + 10 / sc, y + 10 / sc);
      } else if (val.type === 'region') {
        const {x1, y1, x2, y2} = val; const w = x2 - x1, h = y2 - y1;
        g.strokeStyle = colors.region; g.setLineDash([]); g.strokeRect(x1, y1, w, h);
        g.fillStyle = 'rgba(74,163,255,0.12)'; g.fillRect(x1, y1, w, h);
        g.fillStyle = colors.text; g.fillText(labelShort(st.label), x1 + 6 / sc, y1 + 6 / sc);
      }
    }
  }

  function drawCrosshair(x,y,col) {
    const s = 10 / view.scale; ctx.save(); ctx.strokeStyle = col; ctx.beginPath();
    ctx.moveTo(x - s, y); ctx.lineTo(x + s, y); ctx.moveTo(x, y - s); ctx.lineTo(x, y + s); ctx.stroke(); ctx.restore();
  }

  function labelShort(label){return label.replace('Racetrack: ','RT: ').replace('Spin button','Spin').replace('Result panel','Result').replace('Double button','Double');}

  // ---------- UI updates ----------
  function updateUI() {
    const total = steps.length;
    const done = steps.filter(st => data[st.key] && !data[st.key].skipped).length;
    const st = steps[stepIndex];
    stepLabel.textContent = st ? st.label : 'Finished';
    stepHelp.textContent = st ? (st.type === 'point' ? 'Point: single click at center' : 'Region: two clicks (topâ€‘left, bottomâ€‘right)') + ` â€¢ ${st.help || ''}` : 'All steps complete.';
    progressBar.style.width = total ? `${Math.round(done/total*100)}%` : '0%';
    progressText.textContent = `${done} / ${total}`;
  }

  function goToNextStep() {
    for (let i = stepIndex + 1; i < steps.length; i++) { const k = steps[i].key; if (!data[k] || data[k].skipped) { stepIndex = i; updateUI(); return; } }
    for (let i = 0; i < steps.length; i++) { const k = steps[i].key; if (!data[k] || data[k].skipped) { stepIndex = i; updateUI(); return; } }
    stepIndex = steps.length; updateUI();
  }

  function setData(key, value) { const prev = data[key]; data[key] = value; history.push({ key, prevValue: prev, nextValue: value }); updateUI(); draw(); }
  function skipCurrent() { const st = steps[stepIndex]; if (!st) return; setData(st.key, { skipped: true, type: st.type }); pendingRegionFirst = null; goToNextStep(); }

  // ---------- Interactions ----------
  canvas.addEventListener('mousedown', (e) => {
    if (!img) return;
    if (e.button === 1 || e.button === 2 || e.ctrlKey || e.metaKey || e.shiftKey || e.altKey) { isPanning = true; panStart = { x: e.clientX, y: e.clientY }; viewStart = { tx: view.tx, ty: view.ty }; return; }
    const rect = canvas.getBoundingClientRect();
    const cx = (e.clientX - rect.left) * (window.devicePixelRatio || 1);
    const cy = (e.clientY - rect.top) * (window.devicePixelRatio || 1);
    const { x, y } = clampToImage(canvasToImage(cx, cy));
    const st = steps[stepIndex]; if (!st) return;

    if (st.type === 'point') { setData(st.key, { type:'point', x, y }); goToNextStep(); }
    else if (st.type === 'region') {
      if (!pendingRegionFirst) pendingRegionFirst = { x, y };
      else {
        const x1 = Math.min(pendingRegionFirst.x, x), y1 = Math.min(pendingRegionFirst.y, y);
        const x2 = Math.max(pendingRegionFirst.x, x), y2 = Math.max(pendingRegionFirst.y, y);
        if (Math.abs(x2-x1) < 2 || Math.abs(y2-y1) < 2) { pendingRegionFirst = null; draw(); return; }
        setData(st.key, { type:'region', x1, y1, x2, y2 }); pendingRegionFirst = null; goToNextStep();
      }
    }
    draw();
  });

  canvas.addEventListener('mousemove', (e) => { if (!img) return; if (isPanning) { const dpr = window.devicePixelRatio || 1; const dx = (e.clientX - panStart.x) * dpr; const dy = (e.clientY - panStart.y) * dpr; view.tx = viewStart.tx + dx; view.ty = viewStart.ty + dy; draw(); } });
  window.addEventListener('mouseup', () => { isPanning = false; });
  canvas.addEventListener('contextmenu', (e) => e.preventDefault());

  zoomInBtn.addEventListener('click', () => zoomAt(1.15));
  zoomOutBtn.addEventListener('click', () => zoomAt(1/1.15));
  resetViewBtn.addEventListener('click', () => { fitView(); draw(); });

  function zoomAt(scaleFactor) {
    if (!img) return;
    const cx = canvas.width / 2, cy = canvas.height / 2;
    const before = canvasToImage(cx, cy);
    view.scale = Math.max(0.1, Math.min(10, view.scale * scaleFactor));
    const after = canvasToImage(cx, cy);
    view.tx += (after.x - before.x) * view.scale; view.ty += (after.y - before.y) * view.scale; draw();
  }

  undoBtn.addEventListener('click', () => {
    const last = history.pop(); if (!last) return; if (last.prevValue === undefined) delete data[last.key]; else data[last.key] = last.prevValue;
    const idx = steps.findIndex(s => s.key === last.key); if (idx >= 0) stepIndex = idx; pendingRegionFirst = null; updateUI(); draw();
  });
  skipBtn.addEventListener('click', () => skipCurrent());
  racetrackToggle.addEventListener('change', () => resetSteps());
  depthSelect.addEventListener('change', () => resetSteps());
  variantSelect.addEventListener('change', () => { data = {}; history = []; resetSteps(); });
  clearAllBtn.addEventListener('click', (e) => {
    const alsoImage = e.shiftKey; // hold Shift to clear screenshot too
    data = {}; history = []; pendingRegionFirst = null; stepIndex = 0;
    if (alsoImage) { img = null; imgBitmap = null; }
    resetSteps(); draw();
  });

  // ---------- Export / Import ----------
  exportJsonBtn.addEventListener('click', () => {
    const isUS = (variantSelect && variantSelect.value) === 'US';
    const payload = buildExportPayload(isUS);
    // Safety: block impossible settings
    if (rebase.enabled && (!rebase.baseW || !rebase.baseH)) {
      alert('Rebase enabled but Base W/H not set. Disable Rebase or enter Base W/H.');
      return;
    }
    downloadJSON(payload, 'roulette-mapping.json');
  });

  openJsonBtn.addEventListener('click', () => {
    const isUS = (variantSelect && variantSelect.value) === 'US';
    const payload = buildExportPayload(isUS);
    const w = window.open();
    w.document.write('<pre style="white-space:pre-wrap;word-break:break-word;font:12px ui-monospace,Menlo,Consolas,monospace;padding:12px;background:#0b0f14;color:#e7eef7;">' + escapeHtml(JSON.stringify(payload, null, 2)) + '</pre>');
    w.document.close();
  });

  openOverlayBtn.addEventListener('click', () => {
    if (!img) return alert('Upload a screenshot first.');
    const off = document.createElement('canvas'); off.width = img.width; off.height = img.height;
    const octx = off.getContext('2d');
    const base = imgBitmap || img; octx.drawImage(base, 0, 0);
    drawOverlay(octx, true);
    const dataURL = off.toDataURL('image/png'); const w = window.open();
    w.document.write(`<img src="${dataURL}" style="max-width:100%;">`); w.document.close();
  });

  importJsonInput.addEventListener('change', async (e) => {
    const file = e.target.files?.[0]; if (!file) return; const text = await file.text();
    try {
      const payload = JSON.parse(text);
      if (payload && payload.points && typeof payload.points === 'object') {
        data = payload.points;
        if (payload.meta && typeof payload.meta.racetrack === 'boolean') racetrackToggle.checked = payload.meta.racetrack;
        if (payload.layout) variantSelect.value = payload.layout === 'US' ? 'US' : 'EU';
        if (payload.meta && payload.meta.calibration && payload.meta.calibration.grid_bbox) {
          const r = payload.meta.calibration.grid_bbox; data['calib_grid_bbox'] = { type:'region', x1:r.x1, y1:r.y1, x2:r.x2, y2:r.y2 };
        }
        history = []; resetSteps(); draw(); alert('Mapping JSON imported.');
      } else { alert('Invalid JSON format.'); }
    } catch (err) { alert('Failed to parse JSON: ' + err.message); }
  });

  function buildExportPayload(isUS){
    const layout = isUS ? 'US' : 'EU';
    const table_variant = isUS ? 'American' : 'European';
    const regions = buildRegionsFromData(data, isUS);
    const payload = {
      layout_detected: true,
      layout, table_variant,
      meta: {
        tool: 'roulette-mapper-standalone', version: 4,
        timestamp: new Date().toISOString(),
        image: img ? { width: img.width, height: img.height } : null,
        racetrack: racetrackToggle.checked,
        calibration: data['calib_grid_bbox'] && data['calib_grid_bbox'].type === 'region' ? { grid_bbox: pickRegion(data['calib_grid_bbox']) } : null
      },
      regions,
      // also include the raw points for debugging/backward-compat
      points: data
    };

    // NEW: append rebase metadata
    payload.meta.rebase = {
      enabled: rebase.enabled,
      base_width: rebase.baseW,
      base_height: rebase.baseH,
      offset: [rebase.offX, rebase.offY],
      scale: [rebase.scaleX, rebase.scaleY],
    };
    payload.meta.image_size_mapped = img ? [img.width, img.height] : [0,0];

    return payload;
  }

  function buildRegionsFromData(points, isUS){
    // Minimal schema-friendly exporter (buttons, numbers_grid, specials, racetrack, meta)
    const regions = {
      buttons: { Red:[], Black:[], Green:[], Even:[], Odd:[], Low:[], High:[], '1st12':[], '2nd12':[], '3rd12':[], col1:[], col2:[], col3:[], Double:[] },
      numbers_grid: {},
      splits_h: {},
      splits_v: {},
      corners: {},
      streets: {},
      sixlines: {},
      special: {
        first_four_0_1_2_3: [],
        first_five_0_00_1_2_3: [],
        zero_splits: { '0-1':[], '0-2':[], '0-3':[], '0-00':[], '00-2':[], '00-3':[] }
      },
      racetrack: { bbox:[], voisins:[], tiers:[], orphelins:[], jeu_zero:[] },
      meta: { image_size: img ? [img.width, img.height] : [0,0], confidence: 0.0, notes:'', mapper_version:'4.x', generated_at: new Date().toISOString() }
    };

    // Numbers
    regions.numbers_grid['0'] = pickPoint(points['single_0']);
    if (isUS) regions.numbers_grid['00'] = pickPoint(points['single_00']);
    for (let n=1; n<=36; n++) regions.numbers_grid[String(n)] = pickPoint(points[`single_${n}`]);

    // Colors
    regions.buttons.Red   = pickPoint(points['color_red']);
    regions.buttons.Black = pickPoint(points['color_black']);
    regions.buttons.Green = pickPoint(points['color_green']);

    // Even chances
    regions.buttons.Low   = pickPoint(points['even_low']);
    regions.buttons.Even  = pickPoint(points['even_even']);
    regions.buttons.Odd   = pickPoint(points['even_odd']);
    regions.buttons.High  = pickPoint(points['even_high']);

    // Dozens
    regions.buttons['1st12'] = pickPoint(points['dozen_1']);
    regions.buttons['2nd12'] = pickPoint(points['dozen_2']);
    regions.buttons['3rd12'] = pickPoint(points['dozen_3']);

    // Columns
    regions.buttons.col1 = pickPoint(points['column_1']);
    regions.buttons.col2 = pickPoint(points['column_2']);
    regions.buttons.col3 = pickPoint(points['column_3']);

    // Zero area
    regions.special.first_four_0_1_2_3 = pickPoint(points['first_four']);
    regions.special.first_five_0_00_1_2_3 = pickPoint(points['first_five']);
    regions.special.zero_splits['0-1']  = pickPoint(points['split_0_1']);
    regions.special.zero_splits['0-2']  = pickPoint(points['split_0_2']);
    regions.special.zero_splits['0-3']  = pickPoint(points['split_0_3']);
    regions.special.zero_splits['0-00'] = pickPoint(points['split_0_00']);
    regions.special.zero_splits['00-2'] = pickPoint(points['split_00_2']);
    regions.special.zero_splits['00-3'] = pickPoint(points['split_00_3']);

    // Streets and sixlines (points)
    for (let i=0;i<12;i++) regions.streets[`street_${i+1}`] = pickPoint(points[`street_${i+1}`]);
    for (let i=0;i<11;i++) regions.sixlines[`sixline_${i+1}`] = pickPoint(points[`sixline_${i+1}`]);

    // Buttons (regions)
    regions.buttons.Double = pickRegion(points['btn_double']);
    regions.meta.spin_box   = pickRegion(points['btn_spin']);
    regions.meta.result_box = pickRegion(points['btn_result']);

    // Racetrack
    regions.racetrack.bbox       = pickRegion(points['rt_bbox']);
    regions.racetrack.voisins    = pickPoint(points['rt_voisins']);
    regions.racetrack.tiers      = pickPoint(points['rt_tiers']);
    regions.racetrack.orphelins  = pickPoint(points['rt_orphelins']);
    regions.racetrack.jeu_zero   = pickPoint(points['rt_jeu_zero']);

    return regions;
  }

  // REPLACED: pickPoint / pickRegion now apply rebase on export
  function pickPoint(v){
    if (!(v && v.type==='point')) return [];
    const t = applyRebase({ x: v.x, y: v.y });
    return [t.x, t.y];
  }
  function pickRegion(v){
    if (!(v && v.type==='region')) return [];
    const p1 = applyRebase({ x: v.x1, y: v.y1 });
    const p2 = applyRebase({ x: v.x2, y: v.y2 });
    return { x1:p1.x, y1:p1.y, x2:p2.x, y2:p2.y };
  }

  function downloadJSON(obj, filename) { const blob = new Blob([JSON.stringify(obj, null, 2)], {type:'application/json'}); const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=filename; a.click(); URL.revokeObjectURL(url); }
  function escapeHtml(str) { return str.replace(/[&<>\'\"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;',"'":'&#39;','"':'&quot;'}[c])); }

  // ---------- Init ----------
  resizeCanvasToDisplaySize(); resetSteps(); fitView(); draw();
  // Init rebase state from UI
  syncRebaseFromUI();
})();
</script>
</body>
</html>
