<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Roulette Mapper â€“ Standalone (EU/US â€¢ Landscape/Portrait â€¢ Win/Lose/Unknown)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <style>
    :root{
      --bg:#0b0f14; --panel:#10161e; --panel2:#0f141b; --text:#e7eef7; --muted:#9bb0c6;
      --accent:#50e3c2; --danger:#ff6b6b; --warn:#ffc857; --line:#1e2733; --blue:#4aa3ff; --green:#1bd760;
      --orange:#ffb020; --violet:#b08cff; --cyan:#33d1ff; --yellow:#ffe666;
    }
    *{box-sizing:border-box}
    html,body{height:100%; min-height:100vh}
    body{margin:0; background:var(--bg); color:var(--text); font:14px/1.45 Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;}
    header{display:flex; align-items:center; gap:12px; padding:12px 16px; border-bottom:1px solid var(--line);
      background:linear-gradient(180deg, rgba(255,255,255,.03), transparent); position:sticky; top:0; z-index:3}
    header h1{font-size:16px; margin:0; font-weight:600}
    header .tag{padding:4px 8px; border-radius:999px; background:#0e293f; color:#9bd0ff; font-weight:600}
    main{display:grid; grid-template-columns:360px 1fr; height:calc(100vh - 54px)}
    aside{background:var(--panel); border-right:1px solid var(--line); padding:12px; overflow:auto}
    #workspace{position:relative; overflow:hidden; background:var(--panel2)}
    .group{border:1px solid var(--line); border-radius:10px; padding:12px; margin-bottom:12px; background:rgba(255,255,255,0.02)}
    .group h2{margin:0 0 8px 0; font-size:13px; color:var(--muted); text-transform:uppercase; letter-spacing:.06em}
    .row{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
    button{background:#15202b; color:var(--text); border:1px solid var(--line); padding:8px 10px; border-radius:8px; cursor:pointer; font-weight:600}
    button:hover{background:#1a2633}
    button.primary{background:var(--blue); border-color:transparent; color:#031422}
    button.warn{background:var(--warn); color:#1c1405; border-color:transparent}
    button.ghost{background:transparent}
    input[type=file]{display:none}
    label.file{display:inline-flex; align-items:center; gap:8px; cursor:pointer; border:1px dashed var(--line); padding:10px 12px; border-radius:8px}
    .pill{padding:2px 6px; border-radius:6px; background:#0b2030; color:#9bd0ff; font-weight:700; font-size:12px}
    .status{display:flex; gap:8px; align-items:center; color:var(--muted)}
    .progress{height:8px; background:#0f1620; border-radius:6px; overflow:hidden; border:1px solid var(--line)}
    .progress > div{height:100%; background:var(--green); width:0%}
    #canvas{position:absolute; inset:0; width:100%; height:100%; background:#0a0f14; cursor:crosshair}
    .hint{font-size:12px; color:var(--muted)}
    .callout{padding:10px 12px; border:1px solid #193144; background:#0d1f2e; border-radius:10px}
    .sep{height:1px; background:var(--line); margin:8px 0}
    .small{font-size:12px; color:var(--muted)}
    .legend{display:grid; grid-template-columns:repeat(2, minmax(0,1fr)); gap:6px; font-size:12px; color:var(--muted)}
    .badge{padding:2px 6px; border-radius:6px; font-weight:700; font-size:11px}
    .b-lose{background:#2b1f0c; color:var(--orange)}
    .b-win{background:#0f2a18; color:var(--green)}
    .b-unk1{background:#0b2730; color:var(--cyan)}
    .b-unk2{background:#1c1530; color:var(--violet)}
    .b-unk3{background:#2b2a10; color:var(--yellow)}
    #canvasLegend{position:absolute; left:6px; top:6px; background:rgba(0,0,0,.45); padding:6px 8px; border-radius:8px; font:12px ui-monospace, Menlo, Consolas, monospace; color:#cbd5e1; z-index:2; pointer-events:none}
    #canvasLegend .row{display:flex; gap:8px; align-items:center}
    #canvasLegend .dot{width:10px; height:10px; border-radius:50%}
  </style>
</head>
<body>
  <header>
    <h1>Roulette Mapper</h1>
    <span class="tag">Standalone</span>
    <span class="small">Client-side â€¢ No sandbox â€¢ Works in Chrome/Safari</span>
  </header>
  <main>
    <aside>
      <div class="group">
        <h2>Read first</h2>
        <div class="callout small">
          â€¢ Use <b>practice mode</b> or static table screenshots.<br>
          â€¢ Capture <b>full screen</b>, entire layout. Keep identical zoom/window for mapping & runtime.<br>
          â€¢ Hide overlays/popups.
        </div>
      </div>

      <div class="group">
        <h2>Screenshots by HUD state</h2>
        <div class="row">
          <span class="badge b-lose">LOSE</span>
          <label class="file"><input id="fileLose" type="file" accept="image/*"/><span>ðŸ“¤ Upload Lose</span></label>
        </div>
        <div class="row">
          <span class="badge b-win">WIN</span>
          <label class="file"><input id="fileWin" type="file" accept="image/*"/><span>ðŸ“¤ Upload Win</span></label>
        </div>
        <div class="row">
          <span class="badge b-unk1">UNKNOWN A</span>
          <label class="file"><input id="fileUnk1" type="file" accept="image/*"/><span>ðŸ“¤ Upload U_A (optional)</span></label>
        </div>
        <div class="row">
          <span class="badge b-unk2">UNKNOWN B</span>
          <label class="file"><input id="fileUnk2" type="file" accept="image/*"/><span>ðŸ“¤ Upload U_B (optional)</span></label>
        </div>
        <div class="row">
          <span class="badge b-unk3">UNKNOWN C</span>
          <label class="file"><input id="fileUnk3" type="file" accept="image/*"/><span>ðŸ“¤ Upload U_C (optional)</span></label>
        </div>
        <div class="row">
          <label class="nowrap" for="activeState">Active State</label>
          <select id="activeState">
            <option value="lose" selected>LOSE</option>
            <option value="win">WIN</option>
            <option value="unk1">UNKNOWN A</option>
            <option value="unk2">UNKNOWN B</option>
            <option value="unk3">UNKNOWN C</option>
          </select>
          <span class="hint">Determines which automation steps you map now</span>
        </div>
        <div class="row">
          <label class="nowrap" for="overlayBg">Overlay Background</label>
          <select id="overlayBg">
            <option value="active" selected>Active</option>
            <option value="lose">Lose</option>
            <option value="win">Win</option>
            <option value="unk1">U_A</option>
            <option value="unk2">U_B</option>
            <option value="unk3">U_C</option>
          </select>
          <label class="nowrap" for="overlayMode" style="margin-left:6px">Draw</label>
          <select id="overlayMode">
            <option value="active" selected>Active only</option>
            <option value="all">All states</option>
          </select>
        </div>
        <div class="row">
          <button id="resetViewBtn" class="ghost">Reset View</button>
          <button id="zoomOutBtn">Zoom âˆ’</button>
          <button id="zoomInBtn">Zoom +</button>
          <span class="hint">Zoom & pan (drag)</span>
        </div>
      </div>

      <div class="group" id="rebasePanel">
        <h2>Rebase / Scaling (export)</h2>
        <div class="row">
          <label class="nowrap" for="rebaseToggle">Enable</label>
          <input id="rebaseToggle" type="checkbox" />
          <span class="hint">Export in a different coordinate system</span>
        </div>
        <div class="row">
          <label class="nowrap" for="baseWidth">Base W</label>
          <input id="baseWidth" type="number" min="1" step="1" style="width:110px" placeholder="e.g. 2560" />
          <label class="nowrap" for="baseHeight">Base H</label>
          <input id="baseHeight" type="number" min="1" step="1" style="width:110px" placeholder="e.g. 1440" />
        </div>
        <div class="row">
          <label class="nowrap" for="offsetX">Offset X</label>
          <input id="offsetX" type="number" step="1" style="width:110px" value="0" />
          <label class="nowrap" for="offsetY">Offset Y</label>
          <input id="offsetY" type="number" step="1" style="width:110px" value="0" />
        </div>
        <div class="row">
          <label class="nowrap" for="scaleX">Scale X</label>
          <input id="scaleX" type="number" step="0.0001" style="width:110px" value="1" />
          <label class="nowrap" for="scaleY">Scale Y</label>
          <input id="scaleY" type="number" step="0.0001" style="width:110px" value="1" />
        </div>
        <div class="row">
          <button id="autoScaleBtn" class="ghost">Auto-scale from base size</button>
        </div>
      </div>

      <div class="group">
        <h2>Mapping</h2>

        <!-- These two selects still work exactly like before -->
        <div class="row">
          <label class="nowrap" for="variantSelect">Variant</label>
          <select id="variantSelect">
            <option value="EU" selected>European (single-zero)</option>
            <option value="US">American (double-zero)</option>
          </select>
          <span class="hint">Affects singles & zero-area steps</span>
        </div>
        <div class="row">
          <label class="nowrap" for="orientationSelect">Orientation</label>
          <select id="orientationSelect">
            <option value="landscape" selected>Landscape</option>
            <option value="portrait">Portrait</option>
          </select>
        </div>

        <div class="status">
          <span id="stepLabel" class="pill">â€”</span>
          <span id="stepHelp" class="small">Click to startâ€¦</span>
        </div>

        <div class="sep"></div>
        <div class="row">
          <button id="undoBtn">Undo</button>
          <button id="skipBtn" class="warn">Skip</button>
        </div>
        <div class="row">
          <label class="nowrap" for="depthSelect">Depth</label>
          <select id="depthSelect">
            <option value="basic" selected>Basic (â‰ˆ80â€“84)</option>
            <option value="full">Full (ALL bets)</option>
          </select>
          <label class="nowrap" style="margin-left:8px"><input id="racetrackToggle" type="checkbox"/> Include Racetrack steps</label>
        </div>
        <div class="sep"></div>
        <div class="progress"><div id="progressBar"></div></div>
        <div class="small"><span id="progressText">0 / 0</span> mapped</div>
      </div>

      <div class="group">
        <h2>Export / Import</h2>
        <div class="row">
          <button id="exportJsonBtn" class="primary">Export JSON (this orientation)</button>
          <button id="openJsonBtn">Open JSON</button>
        </div>
        <div class="row">
          <button id="openOverlayBtn">Open Overlay PNG</button>
        </div>
        <div class="row">
          <label class="file">
            <input id="importJsonInput" type="file" accept="application/json" />
            <span>ðŸ“¥ Import JSON</span>
          </label>
          <button id="clearAllBtn">Clear</button>
        </div>
      </div>

      <div class="group">
        <h2>Legend</h2>
        <div class="legend">
          <span>â€¢ Singles 0â€“36 (US adds 00)</span>
          <span>â€¢ Colors R/B/G</span>
          <span>â€¢ Dozens / Columns</span>
          <span>â€¢ 1â€“18 / Even / Odd / 19â€“36</span>
          <span>â€¢ Streets (12) & Sixlines (11)</span>
          <span>â€¢ All splits & corners (Full)</span>
          <span>â€¢ Zero area: First Four (EU) / First Five (US)</span>
          <span>â€¢ Zero splits incl. US 0â€“00, 00â€“2/3</span>
          <span>â€¢ Buttons: Spin / Result / Double</span>
          <span>â€¢ Racetrack (optional)</span>
          <span>â€¢ Automation ROIs per HUD state</span>
        </div>
      </div>
    </aside>

    <section id="workspace">
      <div id="canvasLegend" aria-hidden="true">
        <div class="row"><div class="dot" style="background:#ffb020"></div><div>LOSE</div></div>
        <div class="row"><div class="dot" style="background:#1bd760"></div><div>WIN</div></div>
        <div class="row"><div class="dot" style="background:#33d1ff"></div><div>U_A</div></div>
        <div class="row"><div class="dot" style="background:#b08cff"></div><div>U_B</div></div>
        <div class="row"><div class="dot" style="background:#ffe666"></div><div>U_C</div></div>
      </div>
      <canvas id="canvas" tabindex="0" aria-label="mapping canvas"></canvas>
    </section>
  </main>

<script>
(() => {
  // ---------- DOM ----------
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  const zoomInBtn = document.getElementById('zoomInBtn');
  const zoomOutBtn = document.getElementById('zoomOutBtn');
  const resetViewBtn = document.getElementById('resetViewBtn');

  const undoBtn = document.getElementById('undoBtn');
  const skipBtn = document.getElementById('skipBtn');
  const racetrackToggle = document.getElementById('racetrackToggle');
  const exportJsonBtn = document.getElementById('exportJsonBtn');
  const openJsonBtn = document.getElementById('openJsonBtn');
  const openOverlayBtn = document.getElementById('openOverlayBtn');
  const importJsonInput = document.getElementById('importJsonInput');
  const clearAllBtn = document.getElementById('clearAllBtn');
  const stepLabel = document.getElementById('stepLabel');
  const stepHelp = document.getElementById('stepHelp');
  const progressBar = document.getElementById('progressBar');
  const progressText = document.getElementById('progressText');
  const depthSelect = document.getElementById('depthSelect');
  const variantSelect = document.getElementById('variantSelect');
  const orientationSelect = document.getElementById('orientationSelect');

  const rebaseToggle = document.getElementById('rebaseToggle');
  const baseWidthInput = document.getElementById('baseWidth');
  const baseHeightInput = document.getElementById('baseHeight');
  const offsetXInput = document.getElementById('offsetX');
  const offsetYInput = document.getElementById('offsetY');
  const scaleXInput = document.getElementById('scaleX');
  const scaleYInput = document.getElementById('scaleY');
  const autoScaleBtn = document.getElementById('autoScaleBtn');

  const fileLose = document.getElementById('fileLose');
  const fileWin  = document.getElementById('fileWin');
  const fileUnk1 = document.getElementById('fileUnk1');
  const fileUnk2 = document.getElementById('fileUnk2');
  const fileUnk3 = document.getElementById('fileUnk3');

  const activeStateSel = document.getElementById('activeState');
  const overlayBgSel   = document.getElementById('overlayBg');
  const overlayModeSel = document.getElementById('overlayMode');

  // ---------- State ----------
  const ORIENTATIONS = ['landscape','portrait'];
  const STATES = ['lose','win','unk1','unk2','unk3'];
  const STATE_LABEL = { lose:'LOSE', win:'WIN', unk1:'UNKNOWN A', unk2:'UNKNOWN B', unk3:'UNKNOWN C' };
  const STATE_COLOR = {
    lose: { stroke:'#ffb020', fill:'rgba(255,176,32,0.15)' },
    win:  { stroke:'#1bd760', fill:'rgba(27,215,96,0.15)' },
    unk1: { stroke:'#33d1ff', fill:'rgba(51,209,255,0.15)' },
    unk2: { stroke:'#b08cff', fill:'rgba(176,140,255,0.15)' },
    unk3: { stroke:'#ffe666', fill:'rgba(255,230,102,0.15)' },
  };

  let currentOrientation = 'landscape';
  let currentState = 'lose';

  const datasets = {
    landscape: {
      data: {}, history: [],
      imagesByState: { lose:null, win:null, unk1:null, unk2:null, unk3:null },
      bitmapsByState: { lose:null, win:null, unk1:null, unk2:null, unk3:null }
    },
    portrait: {
      data: {}, history: [],
      imagesByState: { lose:null, win:null, unk1:null, unk2:null, unk3:null },
      bitmapsByState: { lose:null, win:null, unk1:null, unk2:null, unk3:null }
    }
  };

  const rebaseByOrient = {
    landscape: { enabled:false, baseW:0, baseH:0, offX:0, offY:0, scaleX:1, scaleY:1 },
    portrait:  { enabled:false, baseW:0, baseH:0, offX:0, offY:0, scaleX:1, scaleY:1 }
  };
  let rebase = rebaseByOrient[currentOrientation];

  // View
  let view = { scale: 1, tx: 0, ty: 0 };
  let isPanning = false, panStart = {x:0, y:0}, viewStart = {tx:0, ty:0};

  // Steps & mapping state
  let steps = [];
  let stepIndex = 0;
  let data = {};
  let history = [];
  let pendingRegionFirst = null;

  const colors = { point:'#50e3c2', region:'#4aa3ff', current:'#ffa657', text:'#e7eef7', ghost:'rgba(255,255,255,0.15)' };

  // ---------- Grid helpers (EU/US share same 1â€“36 grid) ----------
  const streets = Array.from({length:12}, (_,i) => {
    const a = 1 + i*3; return [a, a+1, a+2]; // e.g., [1,2,3], [4,5,6], ...
  });
  const sixlines = Array.from({length:11}, (_,i) => {
    const a = 1 + i*3; return [a, a+1, a+2, a+3, a+4, a+5]; // e.g., [1..6], [4..9], ...
  });
  const horizSplits = (() => {
    // pairs within each street: (a-b, b-c)
    const out = [];
    for (const [a,b,c] of streets) out.push([a,b],[b,c]);
    return out; // 24 pairs? (2 per street Ã— 12 = 24) but per 3 rows it's already per street
  })();
  // Actually horizontal on roulette means side-by-side inside same street; above is correct (24)
  const vertSplits = (() => {
    // per column c=0..11: bottom-mid (1+3c,2+3c) and mid-top (2+3c,3+3c) => 24 total
    const out = [];
    for (let c=0;c<12;c++){
      const b = 1 + 3*c, m = 2 + 3*c, t = 3 + 3*c;
      out.push([b,m],[m,t]);
    }
    return out;
  })();
  const corners = (() => {
    // For each 2x2 block across columns (c=0..10): two corners per column gap => 22
    const out = [];
    for (let c=0;c<11;c++){
      const b1=1+3*c, m1=2+3*c, t1=3+3*c;
      const b2=b1+3, m2=m1+3, t2=t1+3;
      out.push([b1,m1,b2,m2]); // 1,2,4,5
      out.push([m1,t1,m2,t2]); // 2,3,5,6
    }
    return out;
  })();

  // ---------- Rebase helpers ----------
  function syncRebaseFromUI() {
    const R = rebaseByOrient[currentOrientation];
    R.enabled = !!rebaseToggle?.checked;
    R.baseW  = parseInt(baseWidthInput?.value || '0', 10) || 0;
    R.baseH  = parseInt(baseHeightInput?.value || '0', 10) || 0;
    R.offX   = parseFloat(offsetXInput?.value || '0') || 0;
    R.offY   = parseFloat(offsetYInput?.value || '0') || 0;
    R.scaleX = parseFloat(scaleXInput?.value || '1') || 1;
    R.scaleY = parseFloat(scaleYInput?.value || '1') || 1;
    rebase = R;
  }
  function loadRebaseToUI() {
    const R = rebaseByOrient[currentOrientation];
    rebaseToggle.checked = !!R.enabled;
    baseWidthInput.value = R.baseW || '';
    baseHeightInput.value = R.baseH || '';
    offsetXInput.value = R.offX;
    offsetYInput.value = R.offY;
    scaleXInput.value = R.scaleX;
    scaleYInput.value = R.scaleY;
    rebase = R;
  }
  function applyRebase(pt) {
    const R = rebaseByOrient[currentOrientation];
    if (!R.enabled) return { x: Math.round(pt.x), y: Math.round(pt.y) };
    return { x: Math.round(pt.x * R.scaleX + R.offX), y: Math.round(pt.y * R.scaleY + R.offY) };
  }
  [rebaseToggle, baseWidthInput, baseHeightInput, offsetXInput, offsetYInput, scaleXInput, scaleYInput]
    .forEach(el => el && el.addEventListener('input', syncRebaseFromUI));
  autoScaleBtn && autoScaleBtn.addEventListener('click', () => {
    const img = getBackgroundImageForOverlay();
    if (!img) { alert('Upload at least one screenshot.'); return; }
    const bw = parseInt(baseWidthInput.value || '0', 10) || 0;
    const bh = parseInt(baseHeightInput.value || '0', 10) || 0;
    if (!bw || !bh) { alert('Enter Base W/H first.'); return; }
    scaleXInput.value = (bw / img.width).toFixed(6);
    scaleYInput.value = (bh / img.height).toFixed(6);
    syncRebaseFromUI();
  });

  // ---------- Orientation & state switching ----------
  function bindOrientationAliases() {
    const ds = datasets[currentOrientation];
    data = ds.data; history = ds.history; rebase = rebaseByOrient[currentOrientation];
  }
  function saveCurrentOrientationState() {
    const ds = datasets[currentOrientation];
    ds.data = data; ds.history = history;
    rebaseByOrient[currentOrientation] = { ...rebaseByOrient[currentOrientation] };
  }
  function loadOrientation(newOri) {
    saveCurrentOrientationState();
    currentOrientation = newOri;
    bindOrientationAliases();
    loadRebaseToUI();
    pendingRegionFirst = null; stepIndex = 0;
    resetSteps(); fitView(); draw();
  }
  orientationSelect.addEventListener('change', (e) => loadOrientation(e.target.value));
  activeStateSel.addEventListener('change', (e) => { currentState = e.target.value; resetSteps(); fitView(); draw(); });
  overlayBgSel.addEventListener('change', () => { fitView(); draw(); });
  overlayModeSel.addEventListener('change', () => draw());

  // ---------- Image loading per state ----------
  function bindFileInput(inputEl, stateKey){
    inputEl.addEventListener('change', async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      try {
        let bitmap = null;
        try { bitmap = window.createImageBitmap ? await createImageBitmap(file) : null; } catch(_) { bitmap = null; }
        const fr = new FileReader();
        fr.onload = () => {
          const im = new Image();
          im.onload = () => {
            const ds = datasets[currentOrientation];
            ds.imagesByState[stateKey] = im;
            ds.bitmapsByState[stateKey] = bitmap;
            fitView(); draw();
          };
          im.onerror = () => alert('Failed to decode image. Try a different file.');
          im.src = String(fr.result);
        };
        fr.onerror = () => alert('Failed to read image file.');
        fr.readAsDataURL(file);
      } catch (err) { alert('Failed to load image: ' + (err && err.message ? err.message : err)); }
    });
  }
  [ [fileLose,'lose'], [fileWin,'win'], [fileUnk1,'unk1'], [fileUnk2,'unk2'], [fileUnk3,'unk3'] ]
    .forEach(([el, key]) => bindFileInput(el, key));

  // ---------- Build Steps ----------
  function buildSteps(includeRacetrack, depth, variant) {
    const s = [];
    const isUS = variant === 'US';

    // 1) AUTOMATION FIRST (per active state)
    const S = currentState; const SLabel = STATE_LABEL[S];
    s.push({ key:`auto_white_box__${S}`,      label:`AUTO (${SLabel}): WHITE indicator (bbox)`, type:'region', help:'Drag tight around the WHITE indicator (single label/icon).' });
    s.push({ key:`auto_center_q1__${S}`, label:`AUTO (${SLabel}): CENTER quad â€“ TL`, type:'point', help:'Top-Left corner of center number tile. Tilt OK.' });
    s.push({ key:`auto_center_q2__${S}`, label:`AUTO (${SLabel}): CENTER quad â€“ TR`, type:'point', help:'Top-Right corner of center number tile.' });
    s.push({ key:`auto_center_q3__${S}`, label:`AUTO (${SLabel}): CENTER quad â€“ BR`, type:'point', help:'Bottom-Right corner of center number tile.' });
    s.push({ key:`auto_center_q4__${S}`, label:`AUTO (${SLabel}): CENTER quad â€“ BL`, type:'point', help:'Bottom-Left corner of center number tile.' });
    s.push({ key:`auto_left_q1__${S}`,  label:`AUTO (${SLabel}): LEFT quad â€“ TL (optional)`,  type:'point', help:'Only if visible. Four corners like CENTER.' });
    s.push({ key:`auto_left_q2__${S}`,  label:`AUTO (${SLabel}): LEFT quad â€“ TR (optional)`,  type:'point' });
    s.push({ key:`auto_left_q3__${S}`,  label:`AUTO (${SLabel}): LEFT quad â€“ BR (optional)`,  type:'point' });
    s.push({ key:`auto_left_q4__${S}`,  label:`AUTO (${SLabel}): LEFT quad â€“ BL (optional)`,  type:'point' });
    s.push({ key:`auto_right_q1__${S}`, label:`AUTO (${SLabel}): RIGHT quad â€“ TL (optional)`, type:'point', help:'Only if visible. Four corners like CENTER.' });
    s.push({ key:`auto_right_q2__${S}`, label:`AUTO (${SLabel}): RIGHT quad â€“ TR (optional)`, type:'point' });
    s.push({ key:`auto_right_q3__${S}`, label:`AUTO (${SLabel}): RIGHT quad â€“ BR (optional)`, type:'point' });
    s.push({ key:`auto_right_q4__${S}`, label:`AUTO (${SLabel}): RIGHT quad â€“ BL (optional)`, type:'point' });
    s.push({ key:`auto_center_arc_box__${S}`, label:`AUTO (${SLabel}): Center ARC panel (bbox, optional)`, type:'region', help:'Optional helper crop around the 3-tile center arc.' });

    // 2) TABLE BASICS (Singles/Buttons/Groups)
    s.push({ key:`single_0`, label:`Number 0`, type:'point', help:'Click center of 0. (US adds 00 later.)' });
    if (isUS) s.push({ key:`single_00`, label:`Number 00 (US only)`, type:'point', help:'Click center of 00.' });
    for (let n = 1; n <= 36; n++) s.push({ key:`single_${n}`, label:`Number ${n}`, type:'point', help:`Click center of ${n}.` });

    s.push({ key:'color_red',   label:'Color Red',   type:'point', help:'Click the RED area/button.' });
    s.push({ key:'color_black', label:'Color Black', type:'point', help:'Click the BLACK area/button.' });
    s.push({ key:'color_green', label:'Color Green', type:'point', help:'If present; else use 0/00.' });

    s.push({ key:'dozen_1', label:'Dozen: 1st 12', type:'point', help:'Covers 1â€“12.' });
    s.push({ key:'dozen_2', label:'Dozen: 2nd 12', type:'point', help:'Covers 13â€“24.' });
    s.push({ key:'dozen_3', label:'Dozen: 3rd 12', type:'point', help:'Covers 25â€“36.' });

    s.push({ key:'column_1', label:'Column 1', type:'point', help:'Numbers: 1,4,7,â€¦,34.' });
    s.push({ key:'column_2', label:'Column 2', type:'point', help:'Numbers: 2,5,8,â€¦,35.' });
    s.push({ key:'column_3', label:'Column 3', type:'point', help:'Numbers: 3,6,9,â€¦,36.' });

    s.push({ key:'even_low',  label:'Low (1â€“18)',  type:'point' });
    s.push({ key:'even_even', label:'Even',        type:'point' });
    s.push({ key:'even_odd',  label:'Odd',         type:'point' });
    s.push({ key:'even_high', label:'High (19â€“36)',type:'point' });

    // Streets / Sixlines with explicit number lists in help
    for (let i=0;i<12;i++){
      const [a,b,c] = streets[i];
      s.push({ key:`street_${i+1}`, label:`Street ${i+1} (${a},${b},${c})`, type:'point',
        help:`Click the STREET spot aligned with ${a}â€“${b}â€“${c}.` });
    }
    for (let i=0;i<11;i++){
      const L = sixlines[i];
      s.push({ key:`sixline_${i+1}`, label:`Sixline ${i+1} (${L.join(',')})`, type:'point',
        help:`Click the SIXLINE spot covering ${L[0]}â€“${L[5]}.` });
    }

    // Zero area
    if (isUS) {
      s.push({ key:'first_five', label:'First Five (0â€“00â€“1â€“2â€“3)', type:'point', help:'Click the basket area (US only).' });
      s.push({ key:'split_0_00', label:'Split 0â€“00', type:'point' });
      s.push({ key:'split_00_2', label:'Split 00â€“2', type:'point' });
      s.push({ key:'split_00_3', label:'Split 00â€“3', type:'point' });
      s.push({ key:'split_0_1', label:'Split 0â€“1', type:'point' });
      s.push({ key:'split_0_2', label:'Split 0â€“2', type:'point' });
      s.push({ key:'split_0_3', label:'Split 0â€“3', type:'point' });
    } else {
      s.push({ key:'first_four', label:'First Four (0â€“1â€“2â€“3)', type:'point', help:'Click the first four area (EU).' });
      s.push({ key:'split_0_1', label:'Split 0â€“1', type:'point' });
      s.push({ key:'split_0_2', label:'Split 0â€“2', type:'point' });
      s.push({ key:'split_0_3', label:'Split 0â€“3', type:'point' });
    }

    // Calibration + Buttons
    s.push({ key:'calib_grid_bbox', label:'Calibration: Numbers grid bbox', type:'region', help:'Drag tightly around the 1â€“36 grid.' });
    s.push({ key:'btn_spin',   label:'Spin button (bbox)',   type:'region' });
    s.push({ key:'btn_result', label:'Result panel (bbox)',  type:'region' });
    s.push({ key:'btn_double', label:'Double button (bbox)', type:'region' });

    // Racetrack (optional)
    if (includeRacetrack) {
      s.push({ key:'rt_bbox', label:'Racetrack bbox', type:'region' });
      s.push({ key:'rt_voisins',   label:'Racetrack: Voisins',   type:'point' });
      s.push({ key:'rt_tiers',     label:'Racetrack: Tiers',     type:'point' });
      s.push({ key:'rt_orphelins', label:'Racetrack: Orphelins', type:'point' });
      s.push({ key:'rt_jeu_zero',  label:'Racetrack: Jeu ZÃ©ro',  type:'point' });
    }

    // 3) FULL DEPTH: add all regular splits & corners with explicit pairs/blocks
    if (depth === 'full') {
      // Horizontal splits (within each street)
      for (const [a,b] of horizSplits) {
        s.push({ key:`split_h_${a}_${b}`, label:`Split ${a}â€“${b} (street)`, type:'point',
          help:`Click the split line between ${a} and ${b} (same street).` });
      }
      // Vertical splits (between rows)
      for (const [a,b] of vertSplits) {
        s.push({ key:`split_v_${a}_${b}`, label:`Split ${a}â€“${b} (vertical)`, type:'point',
          help:`Click the split line between ${a} and ${b} (vertical).` });
      }
      // Corners (2x2 blocks)
      for (const [p,q,r,t] of corners) {
        s.push({ key:`corner_${p}_${q}_${r}_${t}`, label:`Corner ${p}-${q}-${r}-${t}`, type:'point',
          help:`Click the center of the 2Ã—2 corner (${p},${q},${r},${t}).` });
      }
    }

    return s;
  }

  function resetSteps() {
    steps = buildSteps(
      racetrackToggle.checked,
      (depthSelect && depthSelect.value) || 'basic',
      (variantSelect && variantSelect.value) || 'EU'
    );
    const firstIncomplete = steps.findIndex(st => !data[st.key] || data[st.key].skipped);
    stepIndex = Math.max(0, firstIncomplete === -1 ? 0 : firstIncomplete);
    updateUI(); draw();
  }

  // ---------- View / background ----------
  function getBackgroundImageForOverlay() {
    const ds = datasets[currentOrientation];
    const choice = overlayBgSel.value === 'active' ? currentState : overlayBgSel.value;
    return (ds.bitmapsByState[choice] || ds.imagesByState[choice] || null);
  }

  function fitView() {
    resizeCanvasToDisplaySize();
    const base = getBackgroundImageForOverlay();
    if (!base) return;
    const cw = canvas.width, ch = canvas.height;
    const sx = cw / base.width, sy = ch / base.height;
    const scale = Math.min(sx, sy) * 0.95;
    const imgW = base.width * scale, imgH = base.height * scale;
    view.scale = scale; view.tx = (cw - imgW) / 2; view.ty = (ch - imgH) / 2;
  }

  window.addEventListener('resize', () => { resizeCanvasToDisplaySize(); fitView(); draw(); });

  // ---------- Coordinate math ----------
  function resizeCanvasToDisplaySize() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    const width = Math.max(1, Math.floor(rect.width * dpr));
    const height = Math.max(1, Math.floor(rect.height * dpr));
    if (canvas.width !== width || canvas.height !== height) { canvas.width = width; canvas.height = height; }
  }
  function canvasToImage(x, y) { return { x: (x - view.tx) / view.scale, y: (y - view.ty) / view.scale }; }
  function clampToImage(pt) {
    const base = getBackgroundImageForOverlay(); if (!base) return pt;
    return { x: Math.max(0, Math.min(base.width, pt.x)), y: Math.max(0, Math.min(base.height, pt.y)) };
  }

  // ---------- Draw ----------
  function draw() {
    resizeCanvasToDisplaySize();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width, canvas.height);
    ctx.fillStyle = '#0a0f14'; ctx.fillRect(0,0,canvas.width, canvas.height);

    const base = getBackgroundImageForOverlay();
    document.getElementById('canvasLegend').style.display = base ? 'block' : 'none';

    if (base) {
      ctx.setTransform(view.scale, 0, 0, view.scale, view.tx, view.ty);
      ctx.drawImage(base, 0, 0);
      drawOverlay(ctx);
      const st = steps[stepIndex];
      if (st && st.type === 'region' && pendingRegionFirst) {
        ctx.save(); ctx.globalAlpha = 0.6; ctx.strokeStyle = colors.current; ctx.setLineDash([8,6]);
        drawCrosshair(pendingRegionFirst.x, pendingRegionFirst.y, colors.current); ctx.restore();
      }
    } else {
      ctx.setTransform(1,0,0,1,0,0);
      ctx.font = '14px ui-monospace, Menlo, Consolas, monospace';
      ctx.fillStyle = '#9bb0c6';
      ctx.fillText('Upload a state screenshot (Lose/Win/Unknown) to begin.', 16, 24);
    }
  }

  function drawOverlay(g) {
    const sc = view.scale;
    g.lineWidth = 2 / sc; g.font = `${12 / sc}px ui-monospace, Menlo, Consolas, monospace`; g.textBaseline = 'top';

    const mode = overlayModeSel.value; // 'active' | 'all'
    const toDrawStates = mode === 'all' ? STATES : [currentState];

    drawSharedMappings(g);

    for (const s of toDrawStates) {
      const col = STATE_COLOR[s];
      drawAutomationForState(g, s, col);
    }
  }

  function drawSharedMappings(g){
    const sc = view.scale;
    for (const [key, val] of Object.entries(data)) {
      if (!val || val.skipped) continue;
      if (key.startsWith('auto_')) continue;
      if (key.includes('__')) continue;
      if (val.type === 'point') {
        const {x, y} = val;
        g.fillStyle = colors.point; g.strokeStyle = 'black';
        g.beginPath(); g.arc(x, y, 8 / sc, 0, Math.PI*2); g.fill(); g.stroke();
      } else if (val.type === 'region') {
        const {x1, y1, x2, y2} = val; const w = x2 - x1, h = y2 - y1;
        g.strokeStyle = colors.region; g.setLineDash([]); g.strokeRect(x1, y1, w, h);
        g.fillStyle = 'rgba(74,163,255,0.12)'; g.fillRect(x1, y1, w, h);
      }
    }
  }

  function drawAutomationForState(g, state, col){
    const drawReg = (keyBase, label) => {
      const v = data[`${keyBase}__${state}`];
      if (!(v && v.type==='region')) return;
      const {x1,y1,x2,y2} = v; const w=x2-x1, h=y2-y1;
      g.strokeStyle = col.stroke; g.setLineDash([]); g.strokeRect(x1,y1,w,h);
      g.fillStyle = col.fill; g.fillRect(x1,y1,w,h);
      g.fillStyle = '#cbd5e1'; g.fillText(`${label} (${STATE_LABEL[state]})`, x1 + 6 / view.scale, y1 + 6 / view.scale);
    };

    const drawQuadPoly = (base, label) => {
      const q1 = data[`${base}_q1__${state}`], q2=data[`${base}_q2__${state}`], q3=data[`${base}_q3__${state}`], q4=data[`${base}_q4__${state}`];
      if (!(q1&&q2&&q3&&q4)) return;
      const pts = [q1,q2,q3,q4];
      g.save();
      g.setLineDash([6,5]);
      g.strokeStyle = col.stroke;
      g.beginPath();
      g.moveTo(pts[0].x, pts[0].y);
      for (let i=1;i<pts.length;i++) g.lineTo(pts[i].x, pts[i].y);
      g.closePath();
      g.stroke();
      g.setLineDash([]);
      g.fillStyle = col.stroke;
      const r = 4 / view.scale;
      for (const p of pts) { g.beginPath(); g.arc(p.x, p.y, r, 0, Math.PI*2); g.fill(); }
      const minX = Math.min(...pts.map(p=>p.x)), minY = Math.min(...pts.map(p=>p.y));
      g.fillStyle = '#cbd5e1'; g.fillText(`${label} (${STATE_LABEL[state]})`, minX + 6 / view.scale, minY + 6 / view.scale);
      g.restore();
    };

    drawReg('auto_white_box', 'A: WHITE');
    drawReg('auto_center_arc_box', 'A: ARC panel (opt)');
    drawQuadPoly('auto_center', 'A: CENTER quad');   // non-rect
    const hasLeft  = ['q1','q2','q3','q4'].every(sfx => !!data[`auto_left_${sfx}__${state}`]);
    const hasRight = ['q1','q2','q3','q4'].every(sfx => !!data[`auto_right_${sfx}__${state}`]);
    if (hasLeft)  drawQuadPoly('auto_left',  'A: LEFT quad');
    if (hasRight) drawQuadPoly('auto_right', 'A: RIGHT quad');
  }

  function drawCrosshair(x,y,col) {
    const s = 8 / view.scale;
    ctx.save(); ctx.strokeStyle = col; ctx.beginPath();
    ctx.moveTo(x - s, y); ctx.lineTo(x + s, y); ctx.moveTo(x, y - s); ctx.lineTo(x, y + s); ctx.stroke(); ctx.restore();
  }

  // ---------- UI updates ----------
  function updateUI() {
    const total = steps.length;
    const done = steps.filter(st => data[st.key] && !data[st.key].skipped).length;
    const st = steps[stepIndex];
    stepLabel.textContent = st ? st.label : 'Finished';
    stepHelp.textContent = st ? (st.type === 'point'
       ? 'POINT: click the precise spot. '
       : 'REGION: two clicks (Top-Left, Bottom-Right). ')
       + (st.help ? `â€¢ ${st.help}` : '') : 'All steps complete.';
    progressBar.style.width = total ? `${Math.round(done/total*100)}%` : '0%';
    progressText.textContent = `${done} / ${total}`;
  }

  function goToNextStep() {
    for (let i = stepIndex + 1; i < steps.length; i++) { const k = steps[i].key; if (!data[k] || data[k].skipped) { stepIndex = i; updateUI(); return; } }
    for (let i = 0; i < steps.length; i++) { const k = steps[i].key; if (!data[k] || data[k].skipped) { stepIndex = i; updateUI(); return; } }
    stepIndex = steps.length; updateUI();
  }

  function setData(key, value) { const prev = data[key]; data[key] = value; history.push({ key, prevValue: prev, nextValue: value }); updateUI(); draw(); }
  function skipCurrent() { const st = steps[stepIndex]; if (!st) return; setData(st.key, { skipped: true, type: st.type }); pendingRegionFirst = null; goToNextStep(); }

  // ---------- Interactions ----------
  canvas.addEventListener('mousedown', (e) => {
    const base = getBackgroundImageForOverlay();
    if (!base) return;
    if (e.button === 1 || e.button === 2 || e.ctrlKey || e.metaKey || e.shiftKey || e.altKey) { isPanning = true; panStart = { x: e.clientX, y: e.clientY }; viewStart = { tx: view.tx, ty: view.ty }; return; }
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    const cx = (e.clientX - rect.left) * dpr;
    const cy = (e.clientY - rect.top) * dpr;
    const { x, y } = clampToImage(canvasToImage(cx, cy));
    const st = steps[stepIndex]; if (!st) return;

    if (st.type === 'point') { setData(st.key, { type:'point', x, y }); goToNextStep(); }
    else if (st.type === 'region') {
      if (!pendingRegionFirst) pendingRegionFirst = { x, y };
      else {
        const x1 = Math.min(pendingRegionFirst.x, x), y1 = Math.min(pendingRegionFirst.y, y);
        const x2 = Math.max(pendingRegionFirst.x, x), y2 = Math.max(pendingRegionFirst.y, y);
        if (Math.abs(x2-x1) < 2 || Math.abs(y2-y1) < 2) { pendingRegionFirst = null; draw(); return; }
        setData(st.key, { type:'region', x1, y1, x2, y2 }); pendingRegionFirst = null; goToNextStep();
      }
    }
    draw();
  });

  canvas.addEventListener('mousemove', (e) => {
    if (!isPanning) return;
    const dpr = window.devicePixelRatio || 1;
    const dx = (e.clientX - panStart.x) * dpr;
    const dy = (e.clientY - panStart.y) * dpr;
    view.tx = viewStart.tx + dx; view.ty = viewStart.ty + dy; draw();
  });
  window.addEventListener('mouseup', () => { isPanning = false; });
  canvas.addEventListener('contextmenu', (e) => e.preventDefault());

  zoomInBtn.addEventListener('click', () => zoomAt(1.15));
  zoomOutBtn.addEventListener('click', () => zoomAt(1/1.15));
  resetViewBtn.addEventListener('click', () => { fitView(); draw(); });

  function zoomAt(scaleFactor) {
    const base = getBackgroundImageForOverlay(); if (!base) return;
    const cx = canvas.width / 2, cy = canvas.height / 2;
    const before = canvasToImage(cx, cy);
    view.scale = Math.max(0.1, Math.min(10, view.scale * scaleFactor));
    const after = canvasToImage(cx, cy);
    view.tx += (after.x - before.x) * view.scale; view.ty += (after.y - before.y) * view.scale; draw();
  }

  undoBtn.addEventListener('click', () => {
    const last = history.pop(); if (!last) return;
    if (last.prevValue === undefined) delete data[last.key]; else data[last.key] = last.prevValue;
    const idx = steps.findIndex(s => s.key === last.key); if (idx >= 0) stepIndex = idx;
    pendingRegionFirst = null; updateUI(); draw();
  });
  skipBtn.addEventListener('click', () => skipCurrent());
  racetrackToggle.addEventListener('change', () => resetSteps());
  depthSelect.addEventListener('change', () => resetSteps());
  variantSelect.addEventListener('change', () => { data = {}; history = []; resetSteps(); });

  clearAllBtn.addEventListener('click', (e) => {
    const alsoImages = e.shiftKey;
    data = {}; history = []; pendingRegionFirst = null; stepIndex = 0;
    if (alsoImages) {
      const ds = datasets[currentOrientation];
      STATES.forEach(s => { ds.imagesByState[s] = null; ds.bitmapsByState[s] = null; });
    }
    resetSteps(); draw();
  });

  // ---------- Export / Import ----------
  exportJsonBtn.addEventListener('click', () => {
    const isUS = (variantSelect && variantSelect.value) === 'US';
    const payload = buildExportPayload(isUS);
    const name = `roulette-mapping_${currentOrientation}.json`;
    downloadJSON(payload, name);
  });

  openJsonBtn.addEventListener('click', () => {
    const isUS = (variantSelect && variantSelect.value) === 'US';
    const payload = buildExportPayload(isUS);
    const w = window.open();
    w.document.write('<pre style="white-space:pre-wrap;word-break:break-word;font:12px ui-monospace,Menlo,Consolas,monospace;padding:12px;background:#0b0f14;color:#e7eef7;">' + escapeHtml(JSON.stringify(payload, null, 2)) + '</pre>');
    w.document.close();
  });

  openOverlayBtn.addEventListener('click', () => {
    const base = getBackgroundImageForOverlay();
    if (!base) return alert('Upload at least one state screenshot.');
    const off = document.createElement('canvas'); off.width = base.width; off.height = base.height;
    const octx = off.getContext('2d');
    octx.drawImage(base, 0, 0);
    const bakView = { ...view };
    view = { scale:1, tx:0, ty:0 };
    drawOverlay(octx);
    view = bakView;
    const dataURL = off.toDataURL('image/png'); const w = window.open();
    w.document.write(`<img src="${dataURL}" style="max-width:100%;">`); w.document.close();
  });

  importJsonInput.addEventListener('change', async (e) => {
    const file = e.target.files?.[0]; if (!file) return; const text = await file.text();
    try {
      const payload = JSON.parse(text);
      if (!(payload && (payload.points || payload.automation_states))) { alert('Invalid JSON format.'); return; }

      const incomingOri = (payload.meta && payload.meta.orientation) || currentOrientation;
      if (incomingOri !== currentOrientation) {
        const useIt = confirm(`JSON orientation: "${incomingOri}". Load into that orientation? (OK = switch)`);
        if (useIt) { loadOrientation(incomingOri); }
      }

      datasets[currentOrientation].data = (payload.points && typeof payload.points==='object') ? payload.points : {};
      bindOrientationAliases();

      // hydrate automation_states â†’ internal keys
      if (payload.automation_states) {
        for (const [stateKey, block] of Object.entries(payload.automation_states)) {
          if (block.white_box) data[`auto_white_box__${stateKey}`] = regionToLocal(block.white_box);
          if (block.center_arc_box) data[`auto_center_arc_box__${stateKey}`] = regionToLocal(block.center_arc_box);
          const qC = (block.quads && block.quads.center) || null;
          if (qC && qC.length===4) {
            data[`auto_center_q1__${stateKey}`] = pointToLocal(qC[0]);
            data[`auto_center_q2__${stateKey}`] = pointToLocal(qC[1]);
            data[`auto_center_q3__${stateKey}`] = pointToLocal(qC[2]);
            data[`auto_center_q4__${stateKey}`] = pointToLocal(qC[3]);
          }
          const qL = (block.quads && block.quads.left) || null;
          if (qL && qL.length===4) {
            data[`auto_left_q1__${stateKey}`] = pointToLocal(qL[0]);
            data[`auto_left_q2__${stateKey}`] = pointToLocal(qL[1]);
            data[`auto_left_q3__${stateKey}`] = pointToLocal(qL[2]);
            data[`auto_left_q4__${stateKey}`] = pointToLocal(qL[3]);
          }
          const qR = (block.quads && block.quads.right) || null;
          if (qR && qR.length===4) {
            data[`auto_right_q1__${stateKey}`] = pointToLocal(qR[0]);
            data[`auto_right_q2__${stateKey}`] = pointToLocal(qR[1]);
            data[`auto_right_q3__${stateKey}`] = pointToLocal(qR[2]);
            data[`auto_right_q4__${stateKey}`] = pointToLocal(qR[3]);
          }
        }
      }

      if (payload.meta && payload.meta.racetrack != null) racetrackToggle.checked = !!payload.meta.racetrack;
      if (payload.layout) variantSelect.value = payload.layout === 'US' ? 'US' : 'EU';
      if (payload.meta && payload.meta.calibration && payload.meta.calibration.grid_bbox) {
        const r = payload.meta.calibration.grid_bbox; data['calib_grid_bbox'] = regionToLocal(r);
      }
      if (payload.meta && payload.meta.rebase) {
        rebaseByOrient[currentOrientation] = {
          enabled: !!payload.meta.rebase.enabled,
          baseW: Number(payload.meta.rebase.base_width)||0,
          baseH: Number(payload.meta.rebase.base_height)||0,
          offX: Array.isArray(payload.meta.rebase.offset)? Number(payload.meta.rebase.offset[0])||0 : 0,
          offY: Array.isArray(payload.meta.rebase.offset)? Number(payload.meta.rebase.offset[1])||0 : 0,
          scaleX: Array.isArray(payload.meta.rebase.scale)? Number(payload.meta.rebase.scale[0])||1 : 1,
          scaleY: Array.isArray(payload.meta.rebase.scale)? Number(payload.meta.rebase.scale[1])||1 : 1,
        };
        loadRebaseToUI();
      }
      history = []; resetSteps(); draw(); alert('Mapping JSON imported.');
    } catch (err) { alert('Failed to parse JSON: ' + err.message); }
  });

  // ---------- Export builders ----------
  function buildExportPayload(isUS){
    const layout = isUS ? 'US' : 'EU';
    const table_variant = isUS ? 'American' : 'European';
    const regions = buildRegionsFromData(data, isUS);
    const automation_states = buildAutomationStatesFromData(data);
    const automation_legacy = buildAutomationLegacyFromStates(automation_states);

    return {
      layout_detected: true,
      layout, table_variant,
      meta: {
        tool: 'roulette-mapper-standalone', version: 5,
        timestamp: new Date().toISOString(),
        orientation: currentOrientation,
        racetrack: racetrackToggle.checked,
        calibration: data['calib_grid_bbox'] && data['calib_grid_bbox'].type === 'region' ? { grid_bbox: pickRegion(data['calib_grid_bbox']) } : null,
        rebase: {
          enabled: rebaseByOrient[currentOrientation].enabled,
          base_width: rebaseByOrient[currentOrientation].baseW,
          base_height: rebaseByOrient[currentOrientation].baseH,
          offset: [rebaseByOrient[currentOrientation].offX, rebaseByOrient[currentOrientation].offY],
          scale: [rebaseByOrient[currentOrientation].scaleX, rebaseByOrient[currentOrientation].scaleY],
        },
        image_size_mapped: getAnyImageSize()
      },
      regions,
      automation_states,
      automation: automation_legacy,
      points: data
    };
  }

  function getAnyImageSize(){
    const ds = datasets[currentOrientation];
    for (const s of STATES) {
      const im = ds.imagesByState[s]; if (im) return [im.width, im.height];
    }
    return [0,0];
  }

  function buildRegionsFromData(points, isUS){
    const regions = {
      buttons: { Red:[], Black:[], Green:[], Even:[], Odd:[], Low:[], High:[], '1st12':[], '2nd12':[], '3rd12':[], col1:[], col2:[], col3:[], Double:[] },
      numbers_grid: {},
      splits_h: {}, splits_v: {}, corners: {},
      streets: {}, sixlines: {},
      special: { first_four_0_1_2_3: [], first_five_0_00_1_2_3: [], zero_splits: { '0-1':[], '0-2':[], '0-3':[], '0-00':[], '00-2':[], '00-3':[] } },
      racetrack: { bbox:[], voisins:[], tiers:[], orphelins:[], jeu_zero:[] },
      meta: { image_size: getAnyImageSize(), confidence: 0.0, notes:'', mapper_version:'5.x', generated_at: new Date().toISOString() }
    };

    // Singles
    regions.numbers_grid['0'] = pickPoint(points['single_0']);
    if (isUS) regions.numbers_grid['00'] = pickPoint(points['single_00']);
    for (let n=1; n<=36; n++) regions.numbers_grid[String(n)] = pickPoint(points[`single_${n}`]);

    // Buttons / groups
    regions.buttons.Red   = pickPoint(points['color_red']);
    regions.buttons.Black = pickPoint(points['color_black']);
    regions.buttons.Green = pickPoint(points['color_green']);

    regions.buttons.Low   = pickPoint(points['even_low']);
    regions.buttons.Even  = pickPoint(points['even_even']);
    regions.buttons.Odd   = pickPoint(points['even_odd']);
    regions.buttons.High  = pickPoint(points['even_high']);

    regions.buttons['1st12'] = pickPoint(points['dozen_1']);
    regions.buttons['2nd12'] = pickPoint(points['dozen_2']);
    regions.buttons['3rd12'] = pickPoint(points['dozen_3']);

    regions.buttons.col1 = pickPoint(points['column_1']);
    regions.buttons.col2 = pickPoint(points['column_2']);
    regions.buttons.col3 = pickPoint(points['column_3']);

    // Streets & Sixlines
    for (let i=0;i<12;i++) regions.streets[`street_${i+1}`] = pickPoint(points[`street_${i+1}`]);
    for (let i=0;i<11;i++) regions.sixlines[`sixline_${i+1}`] = pickPoint(points[`sixline_${i+1}`]);

    // Zero area
    regions.special.first_four_0_1_2_3 = pickPoint(points['first_four']);
    regions.special.first_five_0_00_1_2_3 = pickPoint(points['first_five']);
    regions.special.zero_splits['0-1']  = pickPoint(points['split_0_1']);
    regions.special.zero_splits['0-2']  = pickPoint(points['split_0_2']);
    regions.special.zero_splits['0-3']  = pickPoint(points['split_0_3']);
    regions.special.zero_splits['0-00'] = pickPoint(points['split_0_00']);
    regions.special.zero_splits['00-2'] = pickPoint(points['split_00_2']);
    regions.special.zero_splits['00-3'] = pickPoint(points['split_00_3']);

    // Buttons bboxes
    regions.buttons.Double = pickRegion(points['btn_double']);
    regions.meta.spin_box   = pickRegion(points['btn_spin']);
    regions.meta.result_box = pickRegion(points['btn_result']);

    // Racetrack
    regions.racetrack.bbox       = pickRegion(points['rt_bbox']);
    regions.racetrack.voisins    = pickPoint(points['rt_voisins']);
    regions.racetrack.tiers      = pickPoint(points['rt_tiers']);
    regions.racetrack.orphelins  = pickPoint(points['rt_orphelins']);
    regions.racetrack.jeu_zero   = pickPoint(points['rt_jeu_zero']);

    // FULL: splits & corners if present
    for (const [a,b] of horizSplits) regions.splits_h[`${a}-${b}`] = pickPoint(points[`split_h_${a}_${b}`]);
    for (const [a,b] of vertSplits)  regions.splits_v[`${a}-${b}`] = pickPoint(points[`split_v_${a}_${b}`]);
    for (const [p,q,r,t] of corners) regions.corners[`${p}-${q}-${r}-${t}`] = pickPoint(points[`corner_${p}_${q}_${r}_${t}`]);

    return regions;
  }

  // ---------- Automation (per-state) ----------
  function getPoint(points, key){ const v = points[key]; if (!(v && v.type==='point')) return []; const t = applyRebase({ x:v.x, y:v.y }); return [t.x, t.y]; }
  function getQuad(points, base){
    const p1 = getPoint(points, `${base}_q1`), p2 = getPoint(points, `${base}_q2`), p3 = getPoint(points, `${base}_q3`), p4 = getPoint(points, `${base}_q4`);
    if (p1.length && p2.length && p3.length && p4.length) return [p1,p2,p3,p4];
    return [];
  }
  function getQuadForState(points, base, state){
    // Correct lookup: auto_center_q1__win (NOT auto_center__win_q1)
    const p1 = getPoint(points, `${base}_q1__${state}`);
    const p2 = getPoint(points, `${base}_q2__${state}`);
    const p3 = getPoint(points, `${base}_q3__${state}`);
    const p4 = getPoint(points, `${base}_q4__${state}`);
    if (p1.length && p2.length && p3.length && p4.length) return [p1,p2,p3,p4];
    return [];
  }
  function pickRegionState(points, keyBase, state){
    const v = points[`${keyBase}__${state}`];
    if (!(v && v.type==='region')) return null;
    const p1 = applyRebase({ x: v.x1, y: v.y1 }); const p2 = applyRebase({ x: v.x2, y: v.y2 });
    return { x1:p1.x, y1:p1.y, x2:p2.x, y2:p2.y };
  }
  function buildAutomationStatesFromData(points){
    const out = {};
    for (const s of STATES) {
      const white = pickRegionState(points,'auto_white_box',s);
      const arc   = pickRegionState(points,'auto_center_arc_box',s); // optional
      const quadC = getQuadForState(points,'auto_center',s);
      const quadL = getQuadForState(points,'auto_left',s);
      const quadR = getQuadForState(points,'auto_right',s);
      if (white || arc || (quadC && quadC.length)) {
        out[s] = {
          white_box: white || null,
          center_arc_box: arc || null,
          quads: {
            center: quadC || [],
            left:   quadL || [],
            right:  quadR || []
          }
        };
      }
    }
    return out;
  }

  // Legacy union for older observers (uses union boxes, keeps quads if any)
  function buildAutomationLegacyFromStates(states){
    function unionBox(a,b){
      if (!a && !b) return null;
      if (a && !b) return a; if (b && !a) return b;
      return { x1: Math.min(a.x1,b.x1), y1: Math.min(a.y1,b.y1), x2: Math.max(a.x2,b.x2), y2: Math.max(a.y2,b.y2) };
    }
    const lose = states['lose'] || {};
    const win  = states['win']  || {};
    const white = unionBox(lose.white_box, win.white_box);
    const arc   = unionBox(lose.center_arc_box, win.center_arc_box);

    const quadC = (lose.quads?.center?.length===4) ? lose.quads.center
                 : (win.quads?.center?.length===4) ? win.quads.center : [];
    const quadL = (lose.quads?.left?.length===4) ? lose.quads.left
                 : (win.quads?.left?.length===4) ? win.quads.left : [];
    const quadR = (lose.quads?.right?.length===4) ? lose.quads.right
                 : (win.quads?.right?.length===4) ? win.quads.right : [];

    return {
      white_box: white,
      center_arc_box: arc,
      result_box: pickRegion(data['btn_result']) || null,
      quads: { center: quadC, left: quadL, right: quadR }
    };
  }

  // ---------- Helpers ----------
  function pickPoint(v){ if (!(v && v.type==='point')) return []; const t = applyRebase({ x: v.x, y: v.y }); return [t.x, t.y]; }
  function pickRegion(v){ if (!(v && v.type==='region')) return null; const p1 = applyRebase({ x: v.x1, y: v.y1 }); const p2 = applyRebase({ x: v.x2, y: v.y2 }); return { x1:p1.x, y1:p1.y, x2:p2.x, y2:p2.y }; }
  function regionToLocal(r){ if (!r) return null; return { type:'region', x1:r.x1, y1:r.y1, x2:r.x2, y2:r.y2 }; }
  function pointToLocal(p){ if (!p || !Array.isArray(p) || p.length<2) return null; return { type:'point', x:p[0], y:p[1] }; }

  function downloadJSON(obj, filename) { const blob = new Blob([JSON.stringify(obj, null, 2)], {type:'application/json'}); const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=filename; a.click(); URL.revokeObjectURL(url); }
  function escapeHtml(str) { return str.replace(/[&<>\'\"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;',"'":'&#39;','"':'&quot;'}[c])); }

  // ---------- Init ----------
  function initialBind() {
    bindOrientationAliases();
    resizeCanvasToDisplaySize(); resetSteps(); fitView(); draw();
    loadRebaseToUI();
  }
  initialBind();
})();
</script>
</body>
</html>
