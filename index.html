<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Roulette Mapper â€“ Standalone (EU/US â€¢ Landscape/Portrait â€¢ Win/Lose/Unknown)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <style>
    :root{
      --bg:#0b0f14; --panel:#10161e; --panel2:#0f141b; --text:#e7eef7; --muted:#9bb0c6;
      --accent:#50e3c2; --danger:#ff6b6b; --warn:#ffc857; --line:#1e2733; --blue:#4aa3ff; --green:#1bd760;
      --orange:#ffb020; --violet:#b08cff; --cyan:#33d1ff; --yellow:#ffe666;
    }
    *{box-sizing:border-box}
    html,body{height:100%; min-height:100vh}
    body{margin:0; background:var(--bg); color:var(--text); font:14px/1.45 Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;}
    header{display:flex; align-items:center; gap:12px; padding:12px 16px; border-bottom:1px solid var(--line);
      background:linear-gradient(180deg, rgba(255,255,255,.03), transparent); position:sticky; top:0; z-index:3}
    header h1{font-size:16px; margin:0; font-weight:600}
    header .tag{padding:4px 8px; border-radius:999px; background:#0e293f; color:#9bd0ff; font-weight:600}
    main{display:grid; grid-template-columns:360px 1fr; height:calc(100vh - 54px)}
    aside{background:var(--panel); border-right:1px solid var(--line); padding:12px; overflow:auto}
    #workspace{position:relative; overflow:hidden; background:var(--panel2)}
    .group{border:1px solid var(--line); border-radius:10px; padding:12px; margin-bottom:12px; background:rgba(255,255,255,0.02)}
    .group h2{margin:0 0 8px 0; font-size:13px; color:var(--muted); text-transform:uppercase; letter-spacing:.06em}
    .row{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
    button{background:#15202b; color:var(--text); border:1px solid var(--line); padding:8px 10px; border-radius:8px; cursor:pointer; font-weight:600}
    button:hover{background:#1a2633}
    button.primary{background:var(--blue); border-color:transparent; color:#031422}
    button.warn{background:var(--warn); color:#1c1405; border-color:transparent}
    button.ghost{background:transparent}
    input[type=file]{display:none}
    label.file{display:inline-flex; align-items:center; gap:8px; cursor:pointer; border:1px dashed var(--line); padding:10px 12px; border-radius:8px}
    .pill{padding:2px 6px; border-radius:6px; background:#0b2030; color:#9bd0ff; font-weight:700; font-size:12px}
    .status{display:flex; gap:8px; align-items:center; color:var(--muted)}
    .progress{height:8px; background:#0f1620; border-radius:6px; overflow:hidden; border:1px solid var(--line)}
    .progress > div{height:100%; background:var(--green); width:0%}
    #canvas{position:absolute; inset:0; width:100%; height:100%; background:#0a0f14; cursor:crosshair}
    .hint{font-size:12px; color:var(--muted)}
    .callout{padding:10px 12px; border:1px solid #193144; background:#0d1f2e; border-radius:10px}
    .sep{height:1px; background:var(--line); margin:8px 0}
    .small{font-size:12px; color:var(--muted)}
    .legend{display:grid; grid-template-columns:repeat(2, minmax(0,1fr)); gap:6px; font-size:12px; color:var(--muted)}
    .badge{padding:2px 6px; border-radius:6px; font-weight:700; font-size:11px}
    .b-lose{background:#2b1f0c; color:#ffb020}
    .b-win{background:#0f2a18; color:#1bd760}
    .b-unk1{background:#0b2730; color:#33d1ff}
    .b-unk2{background:#1c1530; color:#b08cff}
    .b-unk3{background:#2b2a10; color:#ffe666}
    #canvasLegend{position:absolute; left:6px; top:6px; background:rgba(0,0,0,.45); padding:6px 8px; border-radius:8px; font:12px ui-monospace, Menlo, Consolas, monospace; color:#cbd5e1; z-index:2; pointer-events:none}
    #canvasLegend .row{display:flex; gap:8px; align-items:center}
    #canvasLegend .dot{width:10px; height:10px; border-radius:50%}
  </style>
</head>
<body>
  <header>
    <h1>Roulette Mapper</h1>
    <span class="tag">Standalone</span>
    <span class="small">Client-side â€¢ No sandbox â€¢ Works in Chrome/Safari</span>
  </header>
  <main>
    <aside>
      <div class="group">
        <h2>Read first</h2>
        <div class="callout small">
          â€¢ Use <b>practice mode</b> or static table screenshots.<br>
          â€¢ Capture <b>full screen</b>, entire layout. Keep identical zoom/window for mapping & runtime.<br>
          â€¢ Hide overlays/popups.
        </div>
      </div>

      <div class="group">
        <h2>Screenshots by HUD state</h2>
        <div class="row">
          <span class="badge b-lose">LOSE</span>
          <label class="file"><input id="fileLose" type="file" accept="image/*"/><span>ðŸ“¤ Upload Lose</span></label>
        </div>
        <div class="row">
          <span class="badge b-win">WIN</span>
          <label class="file"><input id="fileWin" type="file" accept="image/*"/><span>ðŸ“¤ Upload Win</span></label>
        </div>
        <div class="row">
          <span class="badge b-unk1">UNKNOWN A</span>
          <label class="file"><input id="fileUnk1" type="file" accept="image/*"/><span>ðŸ“¤ Upload U_A (optional)</span></label>
        </div>
        <div class="row">
          <span class="badge b-unk2">UNKNOWN B</span>
          <label class="file"><input id="fileUnk2" type="file" accept="image/*"/><span>ðŸ“¤ Upload U_B (optional)</span></label>
        </div>
        <div class="row">
          <span class="badge b-unk3">UNKNOWN C</span>
          <label class="file"><input id="fileUnk3" type="file" accept="image/*"/><span>ðŸ“¤ Upload U_C (optional)</span></label>
        </div>
        <div class="row">
          <label class="nowrap" for="activeState">Active State</label>
          <select id="activeState">
            <option value="lose" selected>LOSE</option>
            <option value="win">WIN</option>
            <option value="unk1">UNKNOWN A</option>
            <option value="unk2">UNKNOWN B</option>
            <option value="unk3">UNKNOWN C</option>
          </select>
          <span class="hint">Determines which automation steps you map now</span>
        </div>
        <div class="row">
          <label class="nowrap" for="overlayBg">Overlay Background</label>
          <select id="overlayBg">
            <option value="active" selected>Active</option>
            <option value="lose">Lose</option>
            <option value="win">Win</option>
            <option value="unk1">U_A</option>
            <option value="unk2">U_B</option>
            <option value="unk3">U_C</option>
          </select>
          <label class="nowrap" for="overlayMode" style="margin-left:6px">Draw</label>
          <select id="overlayMode">
            <option value="active" selected>Active only</option>
            <option value="all">All states</option>
          </select>
        </div>
        <div class="row">
          <button id="resetViewBtn" class="ghost">Reset View</button>
          <button id="zoomOutBtn">Zoom âˆ’</button>
          <button id="zoomInBtn">Zoom +</button>
          <span class="hint">Zoom & pan (drag)</span>
        </div>
      </div>

      <div class="group" id="rebasePanel">
        <h2>Rebase / Scaling (export)</h2>
        <div class="row">
          <label class="nowrap" for="rebaseToggle">Enable</label>
          <input id="rebaseToggle" type="checkbox" />
          <span class="hint">Export in a different coordinate system</span>
        </div>
        <div class="row">
          <label class="nowrap" for="baseWidth">Base W</label>
          <input id="baseWidth" type="number" min="1" step="1" style="width:110px" placeholder="e.g. 2560" />
          <label class="nowrap" for="baseHeight">Base H</label>
          <input id="baseHeight" type="number" min="1" step="1" style="width:110px" placeholder="e.g. 1440" />
        </div>
        <div class="row">
          <label class="nowrap" for="offsetX">Offset X</label>
          <input id="offsetX" type="number" step="1" style="width:110px" value="0" />
          <label class="nowrap" for="offsetY">Offset Y</label>
          <input id="offsetY" type="number" step="1" style="width:110px" value="0" />
        </div>
        <div class="row">
          <label class="nowrap" for="scaleX">Scale X</label>
          <input id="scaleX" type="number" step="0.0001" style="width:110px" value="1" />
          <label class="nowrap" for="scaleY">Scale Y</label>
          <input id="scaleY" type="number" step="0.0001" style="width:110px" value="1" />
        </div>
        <div class="row">
          <button id="autoScaleBtn" class="ghost">Auto-scale from base size</button>
        </div>
      </div>

      <div class="group">
        <h2>Mapping</h2>
        <div class="row">
          <label class="nowrap" for="variantSelect">Variant</label>
          <select id="variantSelect">
            <option value="EU" selected>European (single-zero)</option>
            <option value="US">American (double-zero)</option>
          </select>
          <span class="hint">Affects singles & zero-area steps</span>
        </div>
        <div class="row">
          <label class="nowrap" for="orientationSelect">Orientation</label>
          <select id="orientationSelect">
            <option value="landscape" selected>Landscape</option>
            <option value="portrait">Portrait</option>
          </select>
        </div>
        <div class="status">
          <span id="stepLabel" class="pill">â€”</span>
          <span id="stepHelp" class="small">Click to startâ€¦</span>
        </div>
        <div class="sep"></div>
        <div class="row">
          <button id="undoBtn">Undo</button>
          <button id="skipBtn" class="warn">Skip</button>
          <button id="autoBtn" class="primary" title="Auto-map grid bets from WIN+LOSE using current options">AUTO</button>
        </div>
        <div class="row">
          <label class="nowrap" for="depthSelect">Depth</label>
          <select id="depthSelect">
            <option value="basic" selected>Basic (grid bets)</option>
            <option value="full">Full (adds all splits & corners)</option>
          </select>
          <label class="nowrap" style="margin-left:8px"><input id="racetrackToggle" type="checkbox"/> Include Racetrack steps</label>
        </div>
        <div class="sep"></div>
        <div class="progress"><div id="progressBar"></div></div>
        <div class="small"><span id="progressText">0 / 0</span> mapped</div>
      </div>

      <div class="group">
        <h2>Export / Import</h2>
        <div class="row">
          <button id="exportJsonBtn" class="primary">Export JSON (this orientation)</button>
          <button id="openJsonBtn">Open JSON</button>
        </div>
        <div class="row">
          <button id="openOverlayBtn">Open Overlay PNG</button>
        </div>
        <div class="row">
          <label class="file">
            <input id="importJsonInput" type="file" accept="application/json" />
            <span>ðŸ“¥ Import JSON</span>
          </label>
          <button id="clearAllBtn">Clear</button>
        </div>
      </div>

      <div class="group">
        <h2>Legend</h2>
        <div class="legend">
          <span>â€¢ Singles 0â€“36 (US adds 00)</span>
          <span>â€¢ Streets (12) & Sixlines (11)</span>
          <span>â€¢ First Four (EU) / First Five (US)</span>
          <span>â€¢ Zero splits incl. US 0â€“00, 00â€“2/3</span>
          <span>â€¢ (Full) All splits & corners</span>
          <span>â€¢ Buttons: Spin / Result / Double</span>
          <span>â€¢ Racetrack (optional)</span>
          <span>â€¢ Automation ROIs per HUD state</span>
        </div>
      </div>
    </aside>

    <section id="workspace">
      <div id="canvasLegend" aria-hidden="true">
        <div class="row"><div class="dot" style="background:#ffb020"></div><div>LOSE</div></div>
        <div class="row"><div class="dot" style="background:#1bd760"></div><div>WIN</div></div>
        <div class="row"><div class="dot" style="background:#33d1ff"></div><div>U_A</div></div>
        <div class="row"><div class="dot" style="background:#b08cff"></div><div>U_B</div></div>
        <div class="row"><div class="dot" style="background:#ffe666"></div><div>U_C</div></div>
      </div>
      <canvas id="canvas" tabindex="0" aria-label="mapping canvas"></canvas>
    </section>
  </main>

<script>
(() => {
  // ---------- DOM ----------
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  const zoomInBtn = document.getElementById('zoomInBtn');
  const zoomOutBtn = document.getElementById('zoomOutBtn');
  const resetViewBtn = document.getElementById('resetViewBtn');

  const undoBtn = document.getElementById('undoBtn');
  const skipBtn = document.getElementById('skipBtn');
  const racetrackToggle = document.getElementById('racetrackToggle');
  const exportJsonBtn = document.getElementById('exportJsonBtn');
  const openJsonBtn = document.getElementById('openJsonBtn');
  const openOverlayBtn = document.getElementById('openOverlayBtn');
  const importJsonInput = document.getElementById('importJsonInput');
  const clearAllBtn = document.getElementById('clearAllBtn');
  const stepLabel = document.getElementById('stepLabel');
  const stepHelp = document.getElementById('stepHelp');
  const progressBar = document.getElementById('progressBar');
  const progressText = document.getElementById('progressText');
  const depthSelect = document.getElementById('depthSelect');
  const variantSelect = document.getElementById('variantSelect');
  const orientationSelect = document.getElementById('orientationSelect');
  const autoBtn = document.getElementById('autoBtn');

  const rebaseToggle = document.getElementById('rebaseToggle');
  const baseWidthInput = document.getElementById('baseWidth');
  const baseHeightInput = document.getElementById('baseHeight');
  const offsetXInput = document.getElementById('offsetX');
  const offsetYInput = document.getElementById('offsetY');
  const scaleXInput = document.getElementById('scaleX');
  const scaleYInput = document.getElementById('scaleY');
  const autoScaleBtn = document.getElementById('autoScaleBtn');

  const fileLose = document.getElementById('fileLose');
  const fileWin  = document.getElementById('fileWin');
  const fileUnk1 = document.getElementById('fileUnk1');
  const fileUnk2 = document.getElementById('fileUnk2');
  const fileUnk3 = document.getElementById('fileUnk3');

  const activeStateSel = document.getElementById('activeState');
  const overlayBgSel   = document.getElementById('overlayBg');
  const overlayModeSel = document.getElementById('overlayMode');

  // ---------- State ----------
  const ORIENTATIONS = ['landscape','portrait'];
  const STATES = ['lose','win','unk1','unk2','unk3'];
  const STATE_LABEL = { lose:'LOSE', win:'WIN', unk1:'UNKNOWN A', unk2:'UNKNOWN B', unk3:'UNKNOWN C' };
  const STATE_COLOR = {
    lose: { stroke:'#ffb020', fill:'rgba(255,176,32,0.15)' },
    win:  { stroke:'#1bd760', fill:'rgba(27,215,96,0.15)' },
    unk1: { stroke:'#33d1ff', fill:'rgba(51,209,255,0.15)' },
    unk2: { stroke:'#b08cff', fill:'rgba(176,140,255,0.15)' },
    unk3: { stroke:'#ffe666', fill:'rgba(255,230,102,0.15)' },
  };

  let currentOrientation = 'landscape';
  let currentState = 'lose';

  const datasets = {
    landscape: {
      data: {}, history: [],
      imagesByState: { lose:null, win:null, unk1:null, unk2:null, unk3:null },
      bitmapsByState: { lose:null, win:null, unk1:null, unk2:null, unk3:null }
    },
    portrait: {
      data: {}, history: [],
      imagesByState: { lose:null, win:null, unk1:null, unk2:null, unk3:null },
      bitmapsByState: { lose:null, win:null, unk1:null, unk2:null, unk3:null }
    }
  };

  const rebaseByOrient = {
    landscape: { enabled:false, baseW:0, baseH:0, offX:0, offY:0, scaleX:1, scaleY:1 },
    portrait:  { enabled:false, baseW:0, baseH:0, offX:0, offY:0, scaleX:1, scaleY:1 }
  };
  let rebase = rebaseByOrient[currentOrientation];

  // View
  let view = { scale: 1, tx: 0, ty: 0 };
  let isPanning = false, panStart = {x:0, y:0}, viewStart = {tx:0, ty:0};

  // Steps & mapping state
  let steps = [];
  let stepIndex = 0;
  let data = {};
  let history = [];
  let pendingRegionFirst = null;

  const colors = { point:'#50e3c2', region:'#4aa3ff', current:'#ffa657', text:'#e7eef7', ghost:'rgba(255,255,255,0.15)' };

  // ---------- Rebase helpers ----------
  function syncRebaseFromUI() {
    const R = rebaseByOrient[currentOrientation];
    R.enabled = !!rebaseToggle?.checked;
    R.baseW  = parseInt(baseWidthInput?.value || '0', 10) || 0;
    R.baseH  = parseInt(baseHeightInput?.value || '0', 10) || 0;
    R.offX   = parseFloat(offsetXInput?.value || '0') || 0;
    R.offY   = parseFloat(offsetYInput?.value || '0') || 0;
    R.scaleX = parseFloat(scaleXInput?.value || '1') || 1;
    R.scaleY = parseFloat(scaleYInput?.value || '1') || 1;
    rebase = R;
  }
  function loadRebaseToUI() {
    const R = rebaseByOrient[currentOrientation];
    rebaseToggle.checked = !!R.enabled;
    baseWidthInput.value = R.baseW || '';
    baseHeightInput.value = R.baseH || '';
    offsetXInput.value = R.offX;
    offsetYInput.value = R.offY;
    scaleXInput.value = R.scaleX;
    scaleYInput.value = R.scaleY;
    rebase = R;
  }
  function applyRebase(pt) {
    const R = rebaseByOrient[currentOrientation];
    if (!R.enabled) return { x: Math.round(pt.x), y: Math.round(pt.y) };
    return { x: Math.round(pt.x * R.scaleX + R.offX), y: Math.round(pt.y * R.scaleY + R.offY) };
  }
  [rebaseToggle, baseWidthInput, baseHeightInput, offsetXInput, offsetYInput, scaleXInput, scaleYInput]
    .forEach(el => el && el.addEventListener('input', syncRebaseFromUI));
  autoScaleBtn && autoScaleBtn.addEventListener('click', () => {
    const img = getBackgroundImageForOverlay();
    if (!img) { alert('Upload at least one screenshot.'); return; }
    const bw = parseInt(baseWidthInput.value || '0', 10) || 0;
    const bh = parseInt(baseHeightInput.value || '0', 10) || 0;
    if (!bw || !bh) { alert('Enter Base W/H first.'); return; }
    scaleXInput.value = (bw / img.width).toFixed(6);
    scaleYInput.value = (bh / img.height).toFixed(6);
    syncRebaseFromUI();
  });

  // ---------- Orientation & state switching ----------
  function bindOrientationAliases() { const ds = datasets[currentOrientation]; data = ds.data; history = ds.history; rebase = rebaseByOrient[currentOrientation]; }
  function saveCurrentOrientationState() { const ds = datasets[currentOrientation]; ds.data = data; ds.history = history; rebaseByOrient[currentOrientation] = { ...rebaseByOrient[currentOrientation] }; }
  function loadOrientation(newOri) { saveCurrentOrientationState(); currentOrientation = newOri; bindOrientationAliases(); loadRebaseToUI(); pendingRegionFirst = null; stepIndex = 0; resetSteps(); fitView(); draw(); }
  orientationSelect.addEventListener('change', (e) => loadOrientation(e.target.value));
  activeStateSel.addEventListener('change', (e) => { currentState = e.target.value; resetSteps(); fitView(); draw(); });
  overlayBgSel.addEventListener('change', () => { fitView(); draw(); });
  overlayModeSel.addEventListener('change', () => draw());

  // ---------- Image loading per state ----------
  function bindFileInput(inputEl, stateKey){
    inputEl.addEventListener('change', async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      try {
        let bitmap = null;
        try { bitmap = window.createImageBitmap ? await createImageBitmap(file) : null; } catch(_) { bitmap = null; }
        const fr = new FileReader();
        fr.onload = () => {
          const im = new Image();
          im.onload = () => { const ds = datasets[currentOrientation]; ds.imagesByState[stateKey] = im; ds.bitmapsByState[stateKey] = bitmap; fitView(); draw(); };
          im.onerror = () => alert('Failed to decode image. Try a different file.');
          im.src = String(fr.result);
        };
        fr.onerror = () => alert('Failed to read image file.');
        fr.readAsDataURL(file);
      } catch (err) { alert('Failed to load image: ' + (err && err.message ? err.message : err)); }
    });
  }
  [ [fileLose,'lose'], [fileWin,'win'], [fileUnk1,'unk1'], [fileUnk2,'unk2'], [fileUnk3,'unk3'] ].forEach(([el, key]) => bindFileInput(el, key));

  // ---------- Build Steps ----------
  function buildSteps(includeRacetrack, depth, variant) {
    const s = [];
    const isUS = variant === 'US';
    const S = currentState;
    const SLabel = STATE_LABEL[S];

    // 1) Calibration FIRST
    s.push({ key: 'calib_grid_bbox', label: 'Calibration: Numbers grid bbox', type: 'region', help: 'Drag tight around the 1â€“36 grid.' });

    // 2) (optional) automation helpers
    s.push({ key:`auto_white_box__${S}`,      label:`AUTO (${SLabel}): WHITE indicator (bbox)`, type:'region', help:'Drag tight around the WHITE indicator (single label/icon).' });
    s.push({ key:`auto_center_q1__${S}`, label:`AUTO (${SLabel}): CENTER quad â€“ TL`, type:'point', help:'Top-Left corner of center number tile. Tilt OK.' });
    s.push({ key:`auto_center_q2__${S}`, label:`AUTO (${SLabel}): CENTER quad â€“ TR`, type:'point' });
    s.push({ key:`auto_center_q3__${S}`, label:`AUTO (${SLabel}): CENTER quad â€“ BR`, type:'point' });
    s.push({ key:`auto_center_q4__${S}`, label:`AUTO (${SLabel}): CENTER quad â€“ BL`, type:'point' });
    s.push({ key:`auto_left_q1__${S}`,  label:`AUTO (${SLabel}): LEFT quad â€“ TL (optional)`,  type:'point' });
    s.push({ key:`auto_left_q2__${S}`,  label:`AUTO (${SLabel}): LEFT quad â€“ TR (optional)`,  type:'point' });
    s.push({ key:`auto_left_q3__${S}`,  label:`AUTO (${SLabel}): LEFT quad â€“ BR (optional)`,  type:'point' });
    s.push({ key:`auto_left_q4__${S}`,  label:`AUTO (${SLabel}): LEFT quad â€“ BL (optional)`,  type:'point' });
    s.push({ key:`auto_right_q1__${S}`, label:`AUTO (${SLabel}): RIGHT quad â€“ TL (optional)`, type:'point' });
    s.push({ key:`auto_right_q2__${S}`, label:`AUTO (${SLabel}): RIGHT quad â€“ TR (optional)`, type:'point' });
    s.push({ key:`auto_right_q3__${S}`, label:`AUTO (${SLabel}): RIGHT quad â€“ BR (optional)`, type:'point' });
    s.push({ key:`auto_right_q4__${S}`, label:`AUTO (${SLabel}): RIGHT quad â€“ BL (optional)`, type:'point' });
    s.push({ key:`auto_center_arc_box__${S}`, label:`AUTO (${SLabel}): Center ARC panel (bbox, optional)`, type:'region' });

    // 3) Manual points (AUTO will fill too)
    s.push({ key:`single_0`, label:`Number 0`, type:'point' });
    if (isUS) s.push({ key:`single_00`, label:`Number 00 (US only)`, type:'point' });
    for (let n = 1; n <= 36; n++) s.push({ key:`single_${n}`, label:`Number ${n}`, type:'point' });

    for (let i=0;i<12;i++){ const a = 1 + i*3, b=a+1, c=a+2; s.push({ key:`street_${i+1}`, label:`Street ${i+1} (${a},${b},${c})`, type:'point' }); }
    for (let i=0;i<11;i++){ const L = [1+i*3,2+i*3,3+i*3,4+i*3,5+i*3,6+i*3]; s.push({ key:`sixline_${i+1}`, label:`Sixline ${i+1} (${L.join(',')})`, type:'point' }); }

    // Big buttons & ranges (manual)
    s.push({ key:'column_1', label:'Column 1', type:'point' });
    s.push({ key:'column_2', label:'Column 2', type:'point' });
    s.push({ key:'column_3', label:'Column 3', type:'point' });
    s.push({ key:'dozen_1', label:'1st12', type:'point' });
    s.push({ key:'dozen_2', label:'2nd12', type:'point' });
    s.push({ key:'dozen_3', label:'3rd12', type:'point' });
    s.push({ key:'color_red',   label:'Red',   type:'point' });
    s.push({ key:'color_black', label:'Black', type:'point' });
    s.push({ key:'color_green', label:'Green', type:'point' });
    s.push({ key:'even_even', label:'Even', type:'point' });
    s.push({ key:'even_odd',  label:'Odd',  type:'point' });
    s.push({ key:'even_low',  label:'1â€“18 (Low)',  type:'point' });
    s.push({ key:'even_high', label:'19â€“36 (High)', type:'point' });

    // Zero area + trios
    if (isUS) {
      s.push({ key:'first_five', label:'First Five (0â€“00â€“1â€“2â€“3)', type:'point' });
      s.push({ key:'split_0_00', label:'Split 0â€“00', type:'point' });
      s.push({ key:'split_00_2', label:'Split 00â€“2', type:'point' });
      s.push({ key:'split_00_3', label:'Split 00â€“3', type:'point' });
      s.push({ key:'split_0_1', label:'Split 0â€“1', type:'point' });
      s.push({ key:'split_0_2', label:'Split 0â€“2', type:'point' });
      s.push({ key:'split_0_3', label:'Split 0â€“3', type:'point' });
    } else {
      s.push({ key:'first_four', label:'First Four (0â€“1â€“2â€“3)', type:'point' });
      s.push({ key:'split_0_1', label:'Split 0â€“1', type:'point' });
      s.push({ key:'split_0_2', label:'Split 0â€“2', type:'point' });
      s.push({ key:'split_0_3', label:'Split 0â€“3', type:'point' });
    }
    s.push({ key:'trio_0_1_2', label:'Trio 0â€“1â€“2', type:'point' });
    s.push({ key:'trio_0_2_3', label:'Trio 0â€“2â€“3', type:'point' });

    // Full depth: ALL splits & corners
    // Define BOTH families explicitly so naming is correct:
    //   - vertical (within column): 1â€“2, 2â€“3 â€¦ per column
    //   - horizontal (across columns): 1â€“4, 4â€“7 â€¦ per row
    const verticalSplits = []; // within a column
    for (let c=0;c<12;c++){
      const b = 1 + 3*c, m = 2 + 3*c, t = 3 + 3*c;
      verticalSplits.push([b,m],[m,t]);
    }
    const horizontalSplits = [
      ...Array.from({length:11}, (_,k)=>[1+3*k, 4+3*k]), // bottom row  1â€“4 â€¦ 31â€“34
      ...Array.from({length:11}, (_,k)=>[2+3*k, 5+3*k]), // middle row  2â€“5 â€¦ 32â€“35
      ...Array.from({length:11}, (_,k)=>[3+3*k, 6+3*k])  // top row     3â€“6 â€¦ 33â€“36
    ];

    const cornerQuads = [];
    for (let c=0;c<11;c++){
      const b1=1+3*c, m1=2+3*c, t1=3+3*c;
      const b2=b1+3,  m2=m1+3,  t2=t1+3;
      cornerQuads.push([b1,m1,b2,m2],[m1,t1,m2,t2]);
    }

    // Register split/corner steps (always visible; AUTO will place them too)
    for (const [a,b] of verticalSplits)   s.push({ key:`split_v_${a}_${b}`, label:`Split ${a}â€“${b} (vertical)`, type:'point' });
    for (const [a,b] of horizontalSplits) s.push({ key:`split_h_${a}_${b}`, label:`Split ${a}â€“${b} (horizontal)`, type:'point' });
    for (const [p,q,r,t] of cornerQuads)  s.push({ key:`corner_${p}_${q}_${r}_${t}`, label:`Corner ${p}-${q}-${r}-${t}`, type:'point' });

    // Buttons & misc (manual)
    s.push({ key:'btn_spin',   label:'Spin button (bbox)',   type:'region' });
    s.push({ key:'btn_result', label:'Result panel (bbox)',  type:'region' });
    s.push({ key:'btn_double', label:'Double button (bbox)', type:'region' });

    if (includeRacetrack) {
      s.push({ key:'rt_bbox', label:'Racetrack bbox', type:'region' });
      s.push({ key:'rt_voisins',   label:'Racetrack: Voisins',   type:'point' });
      s.push({ key:'rt_tiers',     label:'Racetrack: Tiers',     type:'point' });
      s.push({ key:'rt_orphelins', label:'Racetrack: Orphelins', type:'point' });
      s.push({ key:'rt_jeu_zero',  label:'Racetrack: Jeu ZÃ©ro',  type:'point' });
    }
    return s;
  }

  function resetSteps() {
    steps = buildSteps(
      racetrackToggle.checked,
      (depthSelect && depthSelect.value) || 'basic',
      (variantSelect && variantSelect.value) || 'EU'
    );
    const firstIncomplete = steps.findIndex(st => !data[st.key] || data[st.key].skipped);
    stepIndex = Math.max(0, firstIncomplete === -1 ? 0 : firstIncomplete);
    updateUI(); draw();
  }

  function getBackgroundImageForOverlay() {
    const ds = datasets[currentOrientation];
    const choice = overlayBgSel.value === 'active' ? currentState : overlayBgSel.value;
    return (ds.bitmapsByState[choice] || ds.imagesByState[choice] || null);
  }
  function fitView() {
    resizeCanvasToDisplaySize();
    const base = getBackgroundImageForOverlay(); if (!base) return;
    const cw = canvas.width, ch = canvas.height;
    const sx = cw / base.width, sy = ch / base.height;
    const scale = Math.min(sx, sy) * 0.95;
    const imgW = base.width * scale, imgH = base.height * scale;
    view.scale = scale; view.tx = (cw - imgW) / 2; view.ty = (ch - imgH) / 2;
  }
  window.addEventListener('resize', () => { resizeCanvasToDisplaySize(); fitView(); draw(); });
  function resizeCanvasToDisplaySize() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    const width = Math.max(1, Math.floor(rect.width * dpr));
    const height = Math.max(1, Math.floor(rect.height * dpr));
    if (canvas.width !== width || canvas.height !== height) { canvas.width = width; canvas.height = height; }
  }
  function canvasToImage(x, y) { return { x: (x - view.tx) / view.scale, y: (y - view.ty) / view.scale }; }
  function clampToImage(pt) {
    const base = getBackgroundImageForOverlay(); if (!base) return pt;
    return { x: Math.max(0, Math.min(base.width, pt.x)), y: Math.max(0, Math.min(base.height, pt.y)) };
  }

  function draw() {
    resizeCanvasToDisplaySize();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width, canvas.height);
    ctx.fillStyle = '#0a0f14';
    ctx.fillRect(0,0,canvas.width, canvas.height);
    const base = getBackgroundImageForOverlay();
    document.getElementById('canvasLegend').style.display = base ? 'block' : 'none';
    if (base) {
      ctx.setTransform(view.scale, 0, 0, view.scale, view.tx, view.ty);
      ctx.drawImage(base, 0, 0);
      drawOverlay(ctx);
      const st = steps[stepIndex];
      if (st && st.type === 'region' && pendingRegionFirst) {
        ctx.save(); ctx.globalAlpha = 0.6; ctx.strokeStyle = colors.current; ctx.setLineDash([8,6]);
        drawCrosshair(pendingRegionFirst.x, pendingRegionFirst.y, colors.current);
        ctx.restore();
      }
    } else {
      ctx.setTransform(1,0,0,1,0,0);
      ctx.font = '14px ui-monospace, Menlo, Consolas, monospace';
      ctx.fillStyle = '#9bb0c6';
      ctx.fillText('Upload a state screenshot (Lose/Win/Unknown) to begin.', 16, 24);
    }
  }

  function drawOverlay(g) {
    const sc = view.scale;
    g.lineWidth = 2 / sc;
    g.font = `${12 / sc}px ui-monospace, Menlo, Consolas, monospace`;
    g.textBaseline = 'top';
    const mode = overlayModeSel.value;
    const toDrawStates = mode === 'all' ? STATES : [currentState];
    drawSharedMappings(g);
    for (const s of toDrawStates) { const col = STATE_COLOR[s]; drawAutomationForState(g, s, col); }
  }
  function drawSharedMappings(g){
    const sc = view.scale;
    for (const [key, val] of Object.entries(data)) {
      if (!val || val.skipped) continue;
      if (key.startsWith('auto_')) continue;
      if (key.includes('__')) continue;
      if (val.type === 'point') {
        const {x, y} = val;
        g.fillStyle = colors.point; g.strokeStyle = 'black';
        g.beginPath(); g.arc(x, y, 8 / sc, 0, Math.PI*2); g.fill(); g.stroke();
      } else if (val.type === 'region') {
        const {x1, y1, x2, y2} = val; const w = x2 - x1, h = y2 - y1;
        g.strokeStyle = colors.region; g.setLineDash([]); g.strokeRect(x1, y1, w, h);
        g.fillStyle = 'rgba(74,163,255,0.12)'; g.fillRect(x1, y1, w, h);
      }
    }
  }
  function drawAutomationForState(g, state, col){
    const drawReg = (keyBase, label) => {
      const v = data[`${keyBase}__${state}`]; if (!(v && v.type==='region')) return;
      const {x1,y1,x2,y2} = v; const w=x2-x1, h=y2-y1;
      g.strokeStyle = col.stroke; g.setLineDash([]); g.strokeRect(x1,y1,w,h);
      g.fillStyle = col.fill; g.fillRect(x1,y1,w,h);
      g.fillStyle = '#cbd5e1'; g.fillText(`${label} (${STATE_LABEL[state]})`, x1 + 6 / view.scale, y1 + 6 / view.scale);
    };
    const drawQuadPoly = (base, label) => {
      const q1 = data[`${base}_q1__${state}`], q2=data[`${base}_q2__${state}`], q3=data[`${base}_q3__${state}`], q4=data[`${base}_q4__${state}`];
      if (!(q1&&q2&&q3&&q4)) return;
      const pts = [q1,q2,q3,q4];
      g.save(); g.setLineDash([6,5]); g.strokeStyle = col.stroke;
      g.beginPath(); g.moveTo(pts[0].x, pts[0].y); for (let i=1;i<pts.length;i++) g.lineTo(pts[i].x, pts[i].y);
      g.closePath(); g.stroke(); g.setLineDash([]); g.fillStyle = col.stroke;
      const r = 4 / view.scale; for (const p of pts) { g.beginPath(); g.arc(p.x, p.y, r, 0, Math.PI*2); g.fill(); }
      const minX = Math.min(...pts.map(p=>p.x)), minY = Math.min(...pts.map(p=>p.y));
      g.fillStyle = '#cbd5e1'; g.fillText(`${label} (${STATE_LABEL[state]})`, minX + 6 / view.scale, minY + 6 / view.scale);
      g.restore();
    };
    drawReg('auto_white_box', 'A: WHITE');
    drawReg('auto_center_arc_box', 'A: ARC panel (opt)');
    drawQuadPoly('auto_center', 'A: CENTER quad');
    const hasLeft  = ['q1','q2','q3','q4'].every(sfx => !!data[`auto_left_${sfx}__${state}`]);
    const hasRight = ['q1','q2','q3','q4'].every(sfx => !!data[`auto_right_${sfx}__${state}`]);
    if (hasLeft)  drawQuadPoly('auto_left',  'A: LEFT quad');
    if (hasRight) drawQuadPoly('auto_right', 'A: RIGHT quad');
  }
  function drawCrosshair(x,y,col) {
    const s = 8 / view.scale; ctx.save(); ctx.strokeStyle = col;
    ctx.beginPath(); ctx.moveTo(x - s, y); ctx.lineTo(x + s, y);
    ctx.moveTo(x, y - s); ctx.lineTo(x, y + s); ctx.stroke(); ctx.restore();
  }

  function updateUI() {
    const total = steps.length;
    const done = steps.filter(st => (data[st.key] && !data[st.key].skipped)).length;
    const st = steps[stepIndex];
    stepLabel.textContent = st ? st.label : 'Finished';
    stepHelp.textContent = st ? (st.type === 'point' ? 'POINT: click the precise spot. ' : 'REGION: two clicks (Top-Left, Bottom-Right). ') + (st.help ? `â€¢ ${st.help}` : '') : 'All steps complete.';
    progressBar.style.width = total ? `${Math.round(done/total*100)}%` : '0%';
    progressText.textContent = `${done} / ${total}`;
  }
  function goToNextStep() {
    for (let i = stepIndex + 1; i < steps.length; i++) {
      const k = steps[i].key; if (!data[k] || data[k].skipped) { stepIndex = i; updateUI(); return; }
    }
    for (let i = 0; i < steps.length; i++) {
      const k = steps[i].key; if (!data[k] || data[k].skipped) { stepIndex = i; updateUI(); return; }
    }
    stepIndex = steps.length; updateUI();
  }
  function setData(key, value) { const prev = data[key]; data[key] = value; history.push({ key, prevValue: prev, nextValue: value }); updateUI(); draw(); }
  function skipCurrent() { const st = steps[stepIndex]; if (!st) return; setData(st.key, { skipped: true, type: st.type }); pendingRegionFirst = null; goToNextStep(); }

  canvas.addEventListener('mousedown', (e) => {
    const base = getBackgroundImageForOverlay(); if (!base) return;
    if (e.button === 1 || e.button === 2 || e.ctrlKey || e.metaKey || e.shiftKey || e.altKey) {
      isPanning = true; panStart = { x: e.clientX, y: e.clientY }; viewStart = { tx: view.tx, ty: view.ty }; return;
    }
    const rect = canvas.getBoundingClientRect(); const dpr = window.devicePixelRatio || 1;
    const cx = (e.clientX - rect.left) * dpr; const cy = (e.clientY - rect.top) * dpr;
    const { x, y } = clampToImage(canvasToImage(cx, cy)); const st = steps[stepIndex]; if (!st) return;
    if (st.type === 'point') { setData(st.key, { type:'point', x, y }); goToNextStep(); }
    else if (st.type === 'region') {
      if (!pendingRegionFirst) pendingRegionFirst = { x, y };
      else {
        const x1 = Math.min(pendingRegionFirst.x, x), y1 = Math.min(pendingRegionFirst.y, y);
        const x2 = Math.max(pendingRegionFirst.x, x), y2 = Math.max(pendingRegionFirst.y, y);
        if (Math.abs(x2-x1) < 2 || Math.abs(y2-y1) < 2) { pendingRegionFirst = null; draw(); return; }
        setData(st.key, { type:'region', x1, y1, x2, y2 }); pendingRegionFirst = null; goToNextStep();
      }
    }
    draw();
  });
  canvas.addEventListener('mousemove', (e) => {
    if (!isPanning) return;
    const dpr = window.devicePixelRatio || 1;
    const dx = (e.clientX - panStart.x) * dpr; const dy = (e.clientY - panStart.y) * dpr;
    view.tx = viewStart.tx + dx; view.ty = viewStart.ty + dy; draw();
  });
  window.addEventListener('mouseup', () => { isPanning = false; });
  canvas.addEventListener('contextmenu', (e) => e.preventDefault());
  const zoomAt = (scaleFactor) => {
    const base = getBackgroundImageForOverlay(); if (!base) return;
    const cx = canvas.width / 2, cy = canvas.height / 2;
    const before = canvasToImage(cx, cy);
    view.scale = Math.max(0.1, Math.min(10, view.scale * scaleFactor));
    const after = canvasToImage(cx, cy);
    view.tx += (after.x - before.x) * view.scale;
    view.ty += (after.y - before.y) * view.scale;
    draw();
  };
  zoomInBtn.addEventListener('click', () => zoomAt(1.15));
  zoomOutBtn.addEventListener('click', () => zoomAt(1/1.15));
  resetViewBtn.addEventListener('click', () => { fitView(); draw(); });
  undoBtn.addEventListener('click', () => {
    const last = history.pop(); if (!last) return;
    if (last.prevValue === undefined) delete data[last.key]; else data[last.key] = last.prevValue;
    const idx = steps.findIndex(s => s.key === last.key); if (idx >= 0) stepIndex = idx;
    pendingRegionFirst = null; updateUI(); draw();
  });
  skipBtn.addEventListener('click', () => skipCurrent());
  racetrackToggle.addEventListener('change', () => resetSteps());
  depthSelect.addEventListener('change', () => resetSteps());
  variantSelect.addEventListener('change', () => { data = {}; history = []; resetSteps(); });
  clearAllBtn.addEventListener('click', (e) => {
    const alsoImages = e.shiftKey;
    data = {}; history = []; pendingRegionFirst = null; stepIndex = 0;
    if (alsoImages) {
      const ds = datasets[currentOrientation];
      STATES.forEach(s => { ds.imagesByState[s] = null; ds.bitmapsByState[s] = null; });
    }
    resetSteps(); draw();
  });

  // ---------- AUTO Mapping ----------
  autoBtn.addEventListener('click', () => { try { runAuto(); } catch(err){ alert('AUTO failed: ' + (err?.message || err)); } });
  function hasBothWinLose(){ const ds = datasets[currentOrientation]; return !!(ds.imagesByState.win && ds.imagesByState.lose); }

  function runAuto(){
    if (!hasBothWinLose()) { alert('AUTO needs both WIN and LOSE screenshots loaded.'); return; }

    const isUS  = (variantSelect && variantSelect.value) === 'US';
    const depth = (depthSelect && depthSelect.value) || 'basic';

    // must have calibration first
    const calib = data['calib_grid_bbox'];
    if (!(calib && calib.type==='region')) {
      alert('Please map "Calibration: Numbers grid bbox" first (tight around 1â€“36).');
      return;
    }

    const {x1,y1,x2,y2} = calib;
    const gw = x2 - x1, gh = y2 - y1;
    if (gw <= 0 || gh <= 0) { alert('Invalid grid bbox.'); return; }

    const cw = gw / 12, ch = gh / 3; // cell size
    const setPoint = (k, x, y) => { data[k] = { type:'point', x, y }; };

    // 1) Singles 1..36
    for (let n=1;n<=36;n++){
      const col = Math.ceil(n/3);
      const rowInCol = (n-1)%3; // 0=bottom, 1=middle, 2=top
      const cx = x1 + (col-0.5)*cw;
      const cy = y2 - (rowInCol+0.5)*ch;
      setPoint(`single_${n}`, cx, cy);
    }

    // 0 / 00 positions
    if (isUS) {
      const cx0  = x1 - 0.5*cw, cy0  = y2 - 0.5*ch;
      const cx00 = x1 - 0.5*cw, cy00 = y1 + 0.5*ch;
      setPoint('single_0',  cx0,  cy0);
      setPoint('single_00', cx00, cy00);
    } else {
      const cx0 = x1 - 0.5*cw, cy0 = (y1+y2)/2;
      setPoint('single_0', cx0, cy0);
    }

    const getCenter = (n) => data[`single_${n}`];

    // 2) Splits & Corners
    // vertical: within a column (1â€“2, 2â€“3 ...)
    for (let c=0;c<12;c++){
      const b = 1 + 3*c, m = 2 + 3*c, t = 3 + 3*c;
      const B=getCenter(b), M=getCenter(m), T=getCenter(t);
      if (B&&M) setPoint(`split_v_${b}_${m}`, (B.x+M.x)/2, (B.y+M.y)/2);
      if (M&&T) setPoint(`split_v_${m}_${t}`, (M.x+T.x)/2, (M.y+T.y)/2);
    }
    // horizontal: across columns (+3 delta in same row)
    for (let k=0;k<11;k++){
      const a1 = 1+3*k, a2 = a1+3; // bottom row
      const b1 = 2+3*k, b2 = b1+3; // middle row
      const c1 = 3+3*k, c2 = c1+3; // top row
      const A1=getCenter(a1), A2=getCenter(a2);
      const B1=getCenter(b1), B2=getCenter(b2);
      const C1=getCenter(c1), C2=getCenter(c2);
      if (A1&&A2) setPoint(`split_h_${a1}_${a2}`, (A1.x+A2.x)/2, (A1.y+A2.y)/2);
      if (B1&&B2) setPoint(`split_h_${b1}_${b2}`, (B1.x+B2.x)/2, (B1.y+B2.y)/2);
      if (C1&&C2) setPoint(`split_h_${c1}_${c2}`, (C1.x+C2.x)/2, (C1.y+C2.y)/2);
    }
    // corners (two per boundary between columns)
    for (let c=0;c<11;c++){
      const b1=1+3*c, m1=2+3*c, t1=3+3*c;
      const b2=b1+3,  m2=m1+3,  t2=t1+3;
      const P=getCenter(b1), Q=getCenter(m1), R=getCenter(b2), T=getCenter(m2);
      const P2=getCenter(m1), Q2=getCenter(t1), R2=getCenter(m2), T2=getCenter(t2);
      if (P&&Q&&R&&T)   setPoint(`corner_${b1}_${m1}_${b2}_${m2}`, (P.x+Q.x+R.x+T.x)/4, (P.y+Q.y+R.y+T.y)/4);
      if (P2&&Q2&&R2&&T2) setPoint(`corner_${m1}_${t1}_${m2}_${t2}`, (P2.x+Q2.x+R2.x+T2.x)/4, (P2.y+Q2.y+R2.y+T2.y)/4);
    }

    // 3) Streets & Sixlines at bottom edge
    const EDGE_OFFSET = 0.01;
    for (let i=0;i<12;i++){
      const col = i+1;
      const cx = x1 + (col-0.5)*cw;
      const cy = y2 + EDGE_OFFSET*ch;
      setPoint(`street_${i+1}`, cx, cy);
    }
    for (let i=0;i<11;i++){
      const cx = x1 + (i+1)*cw;
      const cy = y2 + EDGE_OFFSET*ch;
      setPoint(`sixline_${i+1}`, cx, cy);
    }

    // 3.5) Columns & Dozens (manual preferred; we provide suggested geometry)
    const COL_OFFSET = 0.5;
    const colX = x2 + COL_OFFSET * cw;
    setPoint('column_1', colX, y1 + 0.5 * ch);
    setPoint('column_2', colX, y1 + 1.5 * ch);
    setPoint('column_3', colX, y1 + 2.5 * ch);

    const DOZEN_OFFSET = 0.35; // closer to grid as you wanted
    const dozenY = y2 + DOZEN_OFFSET * ch;
    setPoint('dozen_1', x1 +  2 * cw, dozenY);
    setPoint('dozen_2', x1 +  6 * cw, dozenY);
    setPoint('dozen_3', x1 + 10 * cw, dozenY);

    // 4) Zero-area specials
    if (isUS) {
      data['first_five'] = { type: 'point', x: x1, y: (y1 + y2) / 2 };
      data['split_0_00'] = { type: 'point', x: x1 - 0.5 * cw, y: y1 + 1.5 * ch };
      data['split_00_2'] = { type: 'point', x: x1, y: y1 + 1.5 * ch };
      data['split_00_3'] = { type: 'point', x: x1, y: y1 + 0.5 * ch };
      data['split_0_1']  = { type: 'point', x: x1, y: y2 - 0.5 * ch };
      data['split_0_2']  = { type: 'point', x: x1, y: y1 + 1.5 * ch };
      data['split_0_3']  = { type: 'point', x: x1, y: y1 + 0.5 * ch };
    } else {
      data['first_four'] = { type: 'point', x: x1, y: y2 };
      data['split_0_1'] = { type: 'point', x: x1, y: y2 - 0.5 * ch };
      data['split_0_2'] = { type: 'point', x: x1, y: y1 + 1.5 * ch };
      data['split_0_3'] = { type: 'point', x: x1, y: y1 + 0.5 * ch };
    }

    // 5) Trios on the left boundary lines
    setPoint('trio_0_1_2', x1, y2 - ch);
    setPoint('trio_0_2_3', x1, y1 + ch);

    updateUI(); draw();
    alert('AUTO completed. Review overlay and fine-tune if needed.');
  }

  // ---------- Export / Import ----------
  openOverlayBtn.addEventListener('click', () => {
    const base = getBackgroundImageForOverlay(); if (!base) return alert('Upload at least one state screenshot.');
    const off = document.createElement('canvas'); off.width = base.width; off.height = base.height; const octx = off.getContext('2d');
    octx.drawImage(base, 0, 0);
    const bakView = { ...view }; view = { scale:1, tx:0, ty:0 }; drawOverlay(octx); view = bakView;
    const dataURL = off.toDataURL('image/png'); const w = window.open(); w.document.write(`<img src="${dataURL}" style="max-width:100%;">`); w.document.close();
  });

  exportJsonBtn.addEventListener('click', () => {
    const isUS = (variantSelect && variantSelect.value) === 'US';
    const payload = buildExportPayload(isUS);
    const name = `roulette-mapping_${currentOrientation}.json`;
    downloadJSON(payload, name);
  });
  openJsonBtn.addEventListener('click', () => {
    const isUS = (variantSelect && variantSelect.value) === 'US';
    const payload = buildExportPayload(isUS);
    const w = window.open();
    w.document.write('<pre style="white-space:pre-wrap;word-break:break-word;font:12px ui-monospace,Menlo,Consolas,monospace;padding:12px;background:#0b0f14;color:#e7eef7;">' + escapeHtml(JSON.stringify(payload, null, 2)) + '</pre>');
    w.document.close();
  });
  importJsonInput.addEventListener('change', async (e) => {
    const file = e.target.files?.[0]; if (!file) return; const text = await file.text();
    try {
      const payload = JSON.parse(text);
      if (!(payload && (payload.points || payload.automation_states))) { alert('Invalid JSON format.'); return; }
      const incomingOri = (payload.meta && payload.meta.orientation) || currentOrientation;
      if (incomingOri !== currentOrientation) { const useIt = confirm(`JSON orientation: "${incomingOri}". Load into that orientation? (OK = switch)`); if (useIt) { loadOrientation(incomingOri); } }
      datasets[currentOrientation].data = (payload.points && typeof payload.points==='object') ? payload.points : {};
      bindOrientationAliases();
      if (payload.automation_states) {
        for (const [stateKey, block] of Object.entries(payload.automation_states)) {
          if (block.white_box) data[`auto_white_box__${stateKey}`] = regionToLocal(block.white_box);
          if (block.center_arc_box) data[`auto_center_arc_box__${stateKey}`] = regionToLocal(block.center_arc_box);
          const qC = (block.quads && block.quads.center) || null; if (qC && qC.length===4) {
            data[`auto_center_q1__${stateKey}`] = pointToLocal(qC[0]);
            data[`auto_center_q2__${stateKey}`] = pointToLocal(qC[1]);
            data[`auto_center_q3__${stateKey}`] = pointToLocal(qC[2]);
            data[`auto_center_q4__${stateKey}`] = pointToLocal(qC[3]);
          }
          const qL = (block.quads && block.quads.left) || null; if (qL && qL.length===4) {
            data[`auto_left_q1__${stateKey}`] = pointToLocal(qL[0]);
            data[`auto_left_q2__${stateKey}`] = pointToLocal(qL[1]);
            data[`auto_left_q3__${stateKey}`] = pointToLocal(qL[2]);
            data[`auto_left_q4__${stateKey}`] = pointToLocal(qL[3]);
          }
          const qR = (block.quads && block.quads.right) || null; if (qR && qR.length===4) {
            data[`auto_right_q1__${stateKey}`] = pointToLocal(qR[0]);
            data[`auto_right_q2__${stateKey}`] = pointToLocal(qR[1]);
            data[`auto_right_q3__${stateKey}`] = pointToLocal(qR[2]);
            data[`auto_right_q4__${stateKey}`] = pointToLocal(qR[3]);
          }
        }
      }
      if (payload.meta && payload.meta.racetrack != null) racetrackToggle.checked = !!payload.meta.racetrack;
      if (payload.layout) variantSelect.value = payload.layout === 'US' ? 'US' : 'EU';
      if (payload.meta && payload.meta.calibration && payload.meta.calibration.grid_bbox) {
        const r = payload.meta.calibration.grid_bbox; data['calib_grid_bbox'] = regionToLocal(r);
      }
      if (payload.meta && payload.meta.rebase) {
        rebaseByOrient[currentOrientation] = {
          enabled: !!payload.meta.rebase.enabled,
          baseW: Number(payload.meta.rebase.base_width)||0,
          baseH: Number(payload.meta.rebase.base_height)||0,
          offX: Array.isArray(payload.meta.rebase.offset)? Number(payload.meta.rebase.offset[0])||0 : 0,
          offY: Array.isArray(payload.meta.rebase.offset)? Number(payload.meta.rebase.offset[1])||0 : 0,
          scaleX: Array.isArray(payload.meta.rebase.scale)? Number(payload.meta.rebase.scale[0])||1 : 1,
          scaleY: Array.isArray(payload.meta.rebase.scale)? Number(payload.meta.rebase.scale[1])||1 : 1,
        };
        loadRebaseToUI();
      }
      history = []; resetSteps(); draw(); alert('Mapping JSON imported.');
    } catch (err) { alert('Failed to parse JSON: ' + err.message); }
  });

  // ---------- Export builders ----------
  function buildExportPayload(isUS){
    const layout = isUS ? 'US' : 'EU';
    const table_variant = isUS ? 'American' : 'European';
    const regions = buildRegionsFromData(data, isUS);
    const automation_states = buildAutomationStatesFromData(data);
    const automation_legacy = buildAutomationLegacyFromStates(automation_states);
    return {
      layout_detected: true, layout, table_variant,
      meta: {
        tool: 'roulette-mapper-standalone', version: 5, timestamp: new Date().toISOString(),
        orientation: currentOrientation, racetrack: racetrackToggle.checked,
        calibration: data['calib_grid_bbox'] && data['calib_grid_bbox'].type === 'region'
          ? { grid_bbox: pickRegion(data['calib_grid_bbox']) } : null,
        rebase: {
          enabled: rebaseByOrient[currentOrientation].enabled,
          base_width: rebaseByOrient[currentOrientation].baseW,
          base_height: rebaseByOrient[currentOrientation].baseH,
          offset: [rebaseByOrient[currentOrientation].offX, rebaseByOrient[currentOrientation].offY],
          scale: [rebaseByOrient[currentOrientation].scaleX, rebaseByOrient[currentOrientation].scaleY],
        },
        image_size_mapped: getAnyImageSize()
      },
      regions, automation_states, automation: automation_legacy, points: data
    };
  }
  function getAnyImageSize(){
    const ds = datasets[currentOrientation];
    for (const s of STATES) { const im = ds.imagesByState[s]; if (im) return [im.width, im.height]; }
    return [0,0];
  }
  function buildRegionsFromData(points, isUS){
    // Recreate the same arrays used in step builder to avoid drift
    const verticalSplits = [];
    for (let c=0;c<12;c++){
      const b = 1 + 3*c, m = 2 + 3*c, t = 3 + 3*c;
      verticalSplits.push([b,m],[m,t]);
    }
    const horizontalSplits = [
      ...Array.from({length:11}, (_,k)=>[1+3*k, 4+3*k]),
      ...Array.from({length:11}, (_,k)=>[2+3*k, 5+3*k]),
      ...Array.from({length:11}, (_,k)=>[3+3*k, 6+3*k])
    ];
    const cornerQuads = [];
    for (let c=0;c<11;c++){
      const b1=1+3*c, m1=2+3*c, t1=3+3*c;
      const b2=b1+3,  m2=m1+3,  t2=t1+3;
      cornerQuads.push([b1,m1,b2,m2],[m1,t1,m2,t2]);
    }

    const regions = {
      buttons: { Red:[], Black:[], Green:[], Even:[], Odd:[], Low:[], High:[], '1st12':[], '2nd12':[], '3rd12':[], col1:[], col2:[], col3:[], Double:[] },
      numbers_grid: {}, splits_h: {}, splits_v: {}, corners: {}, streets: {}, sixlines: {},
      special: {
        first_four_0_1_2_3: [],
        first_five_0_00_1_2_3: [],
        zero_splits: { '0-1':[], '0-2':[], '0-3':[], '0-00':[], '00-2':[], '00-3':[] },
        zero_trios: { '0-1-2':[], '0-2-3':[] }
      },
      racetrack: { bbox:[], voisins:[], tiers:[], orphelins:[], jeu_zero:[] },
      meta: { image_size: getAnyImageSize(), confidence: 0.0, notes:'', mapper_version:'5.x', generated_at: new Date().toISOString() }
    };

    // singles
    regions.numbers_grid['0'] = pickPoint(points['single_0']);
    if (isUS) regions.numbers_grid['00'] = pickPoint(points['single_00']);
    for (let n=1; n<=36; n++) regions.numbers_grid[String(n)] = pickPoint(points[`single_${n}`]);

    // big buttons if mapped
    regions.buttons.Red = pickPoint(points['color_red']);
    regions.buttons.Black = pickPoint(points['color_black']);
    regions.buttons.Green = pickPoint(points['color_green']);
    regions.buttons.Low   = pickPoint(points['even_low']);
    regions.buttons.Even  = pickPoint(points['even_even']);
    regions.buttons.Odd   = pickPoint(points['even_odd']);
    regions.buttons.High  = pickPoint(points['even_high']);
    regions.buttons['1st12'] = pickPoint(points['dozen_1']);
    regions.buttons['2nd12'] = pickPoint(points['dozen_2']);
    regions.buttons['3rd12'] = pickPoint(points['dozen_3']);
    regions.buttons.col1 = pickPoint(points['column_1']);
    regions.buttons.col2 = pickPoint(points['column_2']);
    regions.buttons.col3 = pickPoint(points['column_3']);

    // streets & sixlines
    for (let i=0;i<12;i++) regions.streets[`street_${i+1}`] = pickPoint(points[`street_${i+1}`]);
    for (let i=0;i<11;i++) regions.sixlines[`sixline_${i+1}`] = pickPoint(points[`sixline_${i+1}`]);

    // specials
    regions.special.first_four_0_1_2_3   = pickPoint(points['first_four']);
    regions.special.first_five_0_00_1_2_3= pickPoint(points['first_five']);
    regions.special.zero_splits['0-1']  = pickPoint(points['split_0_1']);
    regions.special.zero_splits['0-2']  = pickPoint(points['split_0_2']);
    regions.special.zero_splits['0-3']  = pickPoint(points['split_0_3']);
    regions.special.zero_splits['0-00'] = pickPoint(points['split_0_00']);
    regions.special.zero_splits['00-2'] = pickPoint(points['split_00_2']);
    regions.special.zero_splits['00-3'] = pickPoint(points['split_00_3']);
    regions.special.zero_trios['0-1-2'] = pickPoint(points['trio_0_1_2']);
    regions.special.zero_trios['0-2-3'] = pickPoint(points['trio_0_2_3']);

    // buttons & meta
    regions.buttons.Double = pickRegion(points['btn_double']);
    regions.meta.spin_box  = pickRegion(points['btn_spin']);
    regions.meta.result_box= pickRegion(points['btn_result']);

    regions.racetrack.bbox = pickRegion(points['rt_bbox']);
    regions.racetrack.voisins = pickPoint(points['rt_voisins']);
    regions.racetrack.tiers   = pickPoint(points['rt_tiers']);
    regions.racetrack.orphelins = pickPoint(points['rt_orphelins']);
    regions.racetrack.jeu_zero  = pickPoint(points['rt_jeu_zero']);

    // splits & corners
    for (const [a,b] of horizontalSplits) regions.splits_h[`${a}-${b}`] = pickPoint(points[`split_h_${a}_${b}`]);
    for (const [a,b] of verticalSplits)   regions.splits_v[`${a}-${b}`] = pickPoint(points[`split_v_${a}_${b}`]);
    for (const [p,q,r,t] of cornerQuads)  regions.corners[`${p}-${q}-${r}-${t}`] = pickPoint(points[`corner_${p}_${q}_${r}_${t}`]);

    return regions;
  }
  function getPoint(points, key){ const v = points[key]; if (!(v && v.type==='point')) return []; const t = applyRebase({ x:v.x, y:v.y }); return [t.x, t.y]; }
  function getQuadForState(points, base, state){
    const p1 = getPoint(points, `${base}_q1__${state}`);
    const p2 = getPoint(points, `${base}_q2__${state}`);
    const p3 = getPoint(points, `${base}_q3__${state}`);
    const p4 = getPoint(points, `${base}_q4__${state}`);
    if (p1.length && p2.length && p3.length && p4.length) return [p1,p2,p3,p4]; return [];
  }
  function pickRegionState(points, keyBase, state){
    const v = points[`${keyBase}__${state}`]; if (!(v && v.type==='region')) return null;
    const p1 = applyRebase({ x: v.x1, y: v.y1 }); const p2 = applyRebase({ x: v.x2, y: v.y2 });
    return { x1:p1.x, y1:p1.y, x2:p2.x, y2:p2.y };
  }
  function buildAutomationStatesFromData(points){
    const out = {};
    for (const s of STATES) {
      const white = pickRegionState(points,'auto_white_box',s);
      const arc = pickRegionState(points,'auto_center_arc_box',s);
      const quadC = getQuadForState(points,'auto_center',s);
      const quadL = getQuadForState(points,'auto_left',s);
      const quadR = getQuadForState(points,'auto_right',s);
      if (white || arc || (quadC && quadC.length)) {
        out[s] = { white_box: white || null, center_arc_box: arc || null, quads: { center: quadC || [], left: quadL || [], right: quadR || [] } };
      }
    }
    return out;
  }
  function buildAutomationLegacyFromStates(states){
    function unionBox(a,b){
      if (!a && !b) return null; if (a && !b) return a; if (b && !a) return b;
      return { x1: Math.min(a.x1,b.x1), y1: Math.min(a.y1,b.y1), x2: Math.max(a.x2,b.x2), y2: Math.max(a.y2,b.y2) };
    }
    const lose = states['lose'] || {}; const win  = states['win']  || {};
    const white = unionBox(lose.white_box, win.white_box);
    const arc = unionBox(lose.center_arc_box, win.center_arc_box);
    const quadC = (lose.quads?.center?.length===4) ? lose.quads.center : (win.quads?.center?.length===4) ? win.quads.center : [];
    const quadL = (lose.quads?.left?.length===4) ? lose.quads.left : (win.quads?.left?.length===4) ? win.quads.left : [];
    const quadR = (lose.quads?.right?.length===4) ? lose.quads.right : (win.quads?.right?.length===4) ? win.quads.right : [];
    return { white_box: white, center_arc_box: arc, result_box: pickRegion(data['btn_result']) || null, quads: { center: quadC, left: quadL, right: quadR } };
  }
  function pickPoint(v){ if (!(v && v.type==='point')) return []; const t = applyRebase({ x: v.x, y: v.y }); return [t.x, t.y]; }
  function pickRegion(v){ if (!(v && v.type==='region')) return null; const p1 = applyRebase({ x: v.x1, y: v.y1 }); const p2 = applyRebase({ x: v.x2, y: v.y2 }); return { x1:p1.x, y1:p1.y, x2:p2.x, y2:p2.y }; }
  function regionToLocal(r){ if (!r) return null; return { type:'region', x1:r.x1, y1:r.y1, x2:r.x2, y2:r.y2 }; }
  function pointToLocal(p){ if (!p || !Array.isArray(p) || p.length<2) return null; return { type:'point', x:p[0], y:p[1] }; }
  function downloadJSON(obj, filename) { const blob = new Blob([JSON.stringify(obj, null, 2)], {type:'application/json'}); const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=filename; a.click(); URL.revokeObjectURL(url); }
  function escapeHtml(str) { return str.replace(/[&<>\'\"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;',"'":'&#39;','"':'&quot;'}[c])); }
  function initialBind() { bindOrientationAliases(); resizeCanvasToDisplaySize(); resetSteps(); fitView(); draw(); loadRebaseToUI(); }
  initialBind();
})();
</script>
</body>
</html>
